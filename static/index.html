<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Langchain Music Store</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=TikTok+Sans:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --font-size: 16px;
            --background: #FFFFFE;
            --foreground: oklch(0.145 0 0);
            --border: rgba(0, 0, 0, 0.1);
            --muted: #ececf0;
            --muted-foreground: #717182;
            --radius: 0.625rem;
            
            /* Theme colors */
            --teal-50: oklch(0.984 0.014 180.72);
            --teal-200: oklch(0.91 0.096 180.426);
            --teal-400: oklch(0.777 0.152 181.912);
            --teal-500: oklch(0.704 0.14 182.503);
            --teal-600: oklch(0.6 0.118 184.704);
            --teal-700: oklch(0.511 0.096 186.391);
            --teal-800: oklch(0.437 0.078 188.216);
            --teal-900: oklch(0.386 0.063 188.416);
            --amber-50: oklch(0.987 0.022 95.277);
            --amber-500: oklch(0.769 0.188 70.08);
            --amber-600: oklch(0.666 0.179 58.318);
            --amber-900: oklch(0.414 0.112 45.904);
            --orange-600: oklch(0.646 0.222 41.116);
            --gray-50: oklch(0.985 0.002 247.839);
            --gray-100: oklch(0.967 0.003 264.542);
            --gray-200: oklch(0.928 0.006 264.531);
            --gray-300: oklch(0.872 0.01 258.338);
            --gray-400: oklch(0.707 0.022 261.325);
            --gray-500: oklch(0.551 0.027 264.364);
            --gray-600: oklch(0.446 0.03 256.802);
            --gray-700: oklch(0.373 0.034 259.733);
            --gray-900: oklch(0.21 0.034 264.665);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'TikTok Sans', sans-serif;
            font-size: var(--font-size);
            line-height: 1.5;
            color: var(--foreground);
            background: var(--background);
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .app-container {
            min-height: 100vh;
            background: #FFFFFE;
            position: relative;
            overflow: hidden;
        }

        /* Chat layout */
        .chat-wrapper {
            display: flex;
            flex-direction: column;
            height: 100vh;
            max-width: 56rem;
            margin: 0 auto;
            position: relative;
        }

        /* Header */
        .header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 1rem 1.5rem;
            border-bottom: 1px solid var(--gray-200);
            background: #FFFFFE;
            position: relative;
            z-index: 10;
        }

        .header-left {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .logo-icon {
            width: 2rem;
            height: 2rem;
            border-radius: 0.375rem;
            object-fit: cover;
        }

        .header-title {
            color: rgba(0, 0, 0, 0.9);
            font-weight: 500;
        }

        .status-indicator {
            width: 0.5rem;
            height: 0.5rem;
            border-radius: 50%;
            background: var(--teal-500);
            box-shadow: 0 0 8px color-mix(in oklab, var(--teal-500) 60%, transparent);
            margin-left: 0.5rem;
            animation: pulse 1.5s ease-in-out infinite;
        }

        .status-indicator.hidden {
            display: none;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.5); opacity: 0.7; }
        }

        .menu-button {
            padding: 0.5rem;
            border-radius: 0.5rem;
            border: none;
            background: transparent;
            cursor: pointer;
            transition: all 0.15s ease;
        }

        .menu-button:hover {
            background: var(--gray-100);
            transform: scale(1.05);
        }

        .menu-button svg {
            width: 1.25rem;
            height: 1.25rem;
            color: var(--gray-600);
        }

        /* Messages area */
        .messages-area {
            flex: 1;
            overflow-y: auto;
            padding: 2rem 1.5rem;
        }

        .messages-container {
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
        }

        /* Reduce gap after tool calls - they're visually connected to the response */
        .message:has(.tool-container) + .message.assistant {
            margin-top: -1rem;
        }
        
        /* Hide avatar on message immediately following tool call - they're the same speaker */
        .message:has(.tool-container) + .message.assistant > .message-avatar {
            visibility: hidden;
        }

        /* Message bubbles */
        .message {
            display: flex;
            gap: 0.75rem;
            animation: fadeIn 0.3s ease-out;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .message.user {
            justify-content: flex-end;
        }

        .message.assistant {
            justify-content: flex-start;
        }

        .message-avatar {
            flex-shrink: 0;
            width: 2rem;
            height: 2rem;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            border-width: 2px;
            border-style: solid;
            background: white;
        }

        .message.assistant .message-avatar {
            border-color: var(--teal-700);
            box-shadow: 0 1px 3px color-mix(in oklab, var(--teal-500) 10%, transparent);
        }

        .message.user .message-avatar {
            border-color: var(--orange-600);
            box-shadow: 0 1px 3px color-mix(in oklab, var(--amber-500) 10%, transparent);
        }

        .message-avatar svg {
            width: 1rem;
            height: 1rem;
        }

        .message.assistant .message-avatar svg {
            color: var(--teal-700);
        }

        .message.user .message-avatar svg {
            color: var(--orange-600);
        }

        .message-content {
            max-width: min(85%, 800px);
            min-width: 0;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        /* Larger content area for video messages - class-based for reliability */
        .message-content.has-video,
        .message-content:has(.video-card),
        .message-content:has(.video-embed),
        .message-content:has(.video-message-wrapper) {
            max-width: min(95%, 1000px) !important;
        }

        /* Also expand the bubble itself for video */
        .message-content.has-video .message-bubble,
        .message-bubble:has(.video-card),
        .message-bubble:has(.video-embed),
        .message-bubble:has(.video-message-wrapper) {
            max-width: 100%;
            width: 100%;
        }

        @media (max-width: 640px) {
            .message-content {
                max-width: 90%;
                min-width: 0;
            }
            /* Keep video messages wider even on mobile */
            .message-content.has-video,
            .message-content:has(.video-card),
            .message-content:has(.video-embed),
            .message-content:has(.video-message-wrapper) {
                max-width: 95% !important;
            }
        }

        .message-bubble {
            padding: 0.75rem 1rem;
            border-radius: 0.625rem;
            /* Keep line breaks, but don't preserve huge blank gaps */
            white-space: pre-line;
            word-break: break-word;
            display: inline-block;
            max-width: 100%;
        }

        .message.user .message-bubble {
            background: var(--amber-600);
            color: white;
            box-shadow: 0 4px 6px -1px color-mix(in oklab, var(--amber-500) 20%, transparent);
        }

        .message.assistant .message-bubble {
            background: var(--gray-100);
            color: rgba(0, 0, 0, 0.9);
            box-shadow: 0 1px 3px color-mix(in oklab, var(--teal-500) 5%, transparent);
            /* Critical: make assistant bubbles block-level so media can be 100% width
               without causing "shrink-to-fit" percentage sizing glitches. */
            display: flex;
            flex-direction: column;
            width: 100%;
            min-width: 0;
            box-sizing: border-box;
        }

        /* Streaming cursor effect - shows message is still being generated */
        .message-bubble.streaming::after {
            content: '▌';
            color: var(--teal-500);
            animation: blink 0.7s infinite;
            margin-left: 2px;
        }

        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0; }
        }

        .message-text {
            width: 100%;
            min-width: 0;
            word-wrap: break-word;
        }

        /* Global strong styling - teal color throughout */
        .message.assistant .message-bubble strong {
            color: var(--teal-700);
            font-weight: 600;
            overflow-wrap: break-word;
            flex-shrink: 0;
        }

        .message.user .message-content {
            align-items: flex-end;
        }

        .message.assistant .message-content {
            align-items: flex-start;
        }

        /* Inline icons in messages */
        .inline-icon {
            display: inline-flex;
            align-items: center;
            vertical-align: middle;
            margin: 0 0.25rem;
        }

        .inline-icon svg {
            width: 1.1em;
            height: 1.1em;
            display: inline-block;
            color: inherit;
        }

        /* Tool usage display */
        .tool-container {
            border: 2px solid var(--teal-700);
            border-radius: 0.625rem;
            overflow: hidden;
            background: white;
            box-shadow: 0 4px 6px -1px color-mix(in oklab, var(--teal-500) 5%, transparent);
        }

        .tool-header {
            width: 100%;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.75rem 1rem;
            background: var(--teal-700);
            border: none;
            cursor: pointer;
            transition: background 0.15s ease;
        }

        .tool-header:hover {
            background: var(--teal-800);
        }

        .tool-header-left {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .tool-header svg {
            width: 1rem;
            height: 1rem;
            color: white;
        }

        .tool-name {
            color: white;
            font-weight: 500;
            font-size: 0.875rem;
        }

        .tool-chevron {
            transition: transform 0.3s ease;
        }

        .tool-chevron.expanded {
            transform: rotate(180deg);
        }

        .tool-content {
            overflow: hidden;
            max-height: 0;
            transition: max-height 0.3s ease;
        }

        .tool-content.expanded {
            max-height: 500px;
        }

        .tool-content-inner {
            padding: 0.75rem 1rem;
            border-top: 2px solid var(--teal-700);
            background: white;
        }

        .tool-section {
            margin-bottom: 0.5rem;
        }

        .tool-section:last-child {
            margin-bottom: 0;
        }

        .tool-section-label {
            font-size: 0.75rem;
            color: color-mix(in oklab, var(--teal-700) 80%, transparent);
            margin-bottom: 0.25rem;
        }

        .tool-section-content {
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, monospace;
            font-size: 0.75rem;
            color: color-mix(in oklab, var(--gray-700) 90%, transparent);
            background: var(--gray-50);
            padding: 0.5rem;
            border-radius: 0.25rem;
            overflow-x: auto;
            white-space: pre-wrap;
            word-break: break-all;
        }

        /* Node indicator */
        .node-indicator {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.375rem 0.75rem;
            background: var(--gray-100);
            border-radius: 9999px;
            font-size: 0.7rem;
            color: var(--gray-500);
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, monospace;
            animation: fadeIn 0.2s ease-out;
        }

        .node-indicator.active {
            color: var(--teal-700);
            border: 1px solid color-mix(in oklab, var(--teal-600) 50%, transparent);
        }

        .node-dot {
            width: 0.375rem;
            height: 0.375rem;
            background: var(--teal-500);
            border-radius: 50%;
            animation: pulse 1s ease-in-out infinite;
        }

        /* Typing indicator */
        .typing-indicator {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            animation: fadeIn 0.3s ease-out;
        }

        .typing-avatar {
            flex-shrink: 0;
            width: 2rem;
            height: 2rem;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 1px solid var(--teal-200);
            background: white;
            box-shadow: 0 1px 3px color-mix(in oklab, var(--teal-500) 10%, transparent);
        }

        .typing-avatar svg {
            width: 1rem;
            height: 1rem;
            color: var(--teal-700);
        }

        .typing-content {
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .typing-icon svg {
            width: 1.25rem;
            height: 1.25rem;
            color: var(--teal-700);
            animation: iconSpin 0.3s ease-out;
        }

        @keyframes iconSpin {
            from { opacity: 0; transform: scale(0.8) rotate(-10deg); }
            to { opacity: 1; transform: scale(1) rotate(0); }
        }

        .typing-text {
            color: color-mix(in oklab, var(--gray-500) 80%, transparent);
            font-size: 0.875rem;
        }

        .typing-dots {
            display: flex;
            gap: 0.25rem;
        }

        .typing-dot {
            width: 0.375rem;
            height: 0.375rem;
            background: var(--teal-500);
            border-radius: 50%;
            animation: typingBounce 1s ease-in-out infinite;
        }

        .typing-dot:nth-child(2) { animation-delay: 0.2s; }
        .typing-dot:nth-child(3) { animation-delay: 0.4s; }

        @keyframes typingBounce {
            0%, 60%, 100% { transform: scale(1); opacity: 0.3; }
            30% { transform: scale(1.3); opacity: 1; }
        }

        /* Pending response indicator - Claude-style "waiting for response" after tool calls */
        .pending-response-indicator {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 0.5rem 0;
            animation: slideIn 0.3s ease-out;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(-8px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .pending-response-indicator.fade-out {
            animation: fadeOut 0.15s ease-out forwards;
            position: absolute;
            pointer-events: none;
        }

        @keyframes fadeOut {
            to {
                opacity: 0;
                transform: translateY(-4px);
            }
        }

        .pending-avatar {
            flex-shrink: 0;
            width: 2rem;
            height: 2rem;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 1px solid var(--teal-200);
            background: white;
            box-shadow: 0 1px 3px color-mix(in oklab, var(--teal-500) 10%, transparent);
        }

        .pending-avatar svg {
            width: 1rem;
            height: 1rem;
            color: var(--teal-700);
        }

        .pending-content {
            display: flex;
            align-items: center;
            padding: 0.5rem 0.75rem;
            background: var(--gray-100);
            border-radius: 1rem;
        }

        .pending-dots {
            display: flex;
            gap: 0.25rem;
        }

        .pending-dot {
            width: 0.375rem;
            height: 0.375rem;
            background: var(--teal-500);
            border-radius: 50%;
            animation: typingBounce 1s ease-in-out infinite;
        }

        .pending-dot:nth-child(2) { animation-delay: 0.2s; }
        .pending-dot:nth-child(3) { animation-delay: 0.4s; }

        /* Input area */
        .input-area {
            padding: 1rem 1.5rem;
            border-top: 1px solid var(--gray-200);
            background: #FFFFFE;
            position: relative;
            z-index: 10;
        }

        .input-container {
            max-width: 48rem;
            margin: 0 auto;
        }

        .input-wrapper {
            display: flex;
            align-items: flex-end;
            gap: 0.75rem;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 0.75rem;
            border: 2px solid var(--gray-200);
            transition: all 0.3s ease;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
        }

        .input-wrapper.focused {
            border-color: var(--teal-600);
            box-shadow: 0 10px 15px -3px color-mix(in oklab, var(--teal-600) 20%, transparent);
        }

        .message-input {
            flex: 1;
            padding: 0.75rem 1rem;
            border: none;
            background: transparent;
            resize: none;
            outline: none;
            font-family: inherit;
            font-size: 1rem;
            line-height: 1.5;
            min-height: 52px;
            max-height: 200px;
            color: var(--gray-900);
        }

        .message-input::placeholder {
            color: var(--gray-400);
        }

        .send-button {
            margin: 0.5rem;
            padding: 0.5rem;
            border-radius: 0.5rem;
            border: 2px solid var(--gray-300);
            background: var(--gray-100);
            color: var(--gray-400);
            cursor: not-allowed;
            transition: all 0.15s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .send-button.active {
            background: var(--teal-600);
            border-color: var(--teal-600);
            color: white;
            cursor: pointer;
            box-shadow: 0 4px 6px -1px color-mix(in oklab, var(--teal-500) 30%, transparent);
        }

        .send-button.active:hover {
            background: var(--teal-700);
        }

        .send-button svg {
            width: 1.25rem;
            height: 1.25rem;
        }

        .input-footer {
            text-align: center;
            color: color-mix(in oklab, var(--gray-400) 80%, transparent);
            margin-top: 0.75rem;
            font-size: 0.875rem;
        }

        /* Welcome screen */
        .welcome-screen {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            padding: 3rem 2.5rem;
            max-width: 480px;
            margin: 0 auto;
            /* Glass card with teal border */
            background: rgba(255, 255, 255, 0.5);
            border-radius: 1.5rem;
            border: 2px solid var(--teal-600);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
        }

        /* Staggered entrance animations */
        @keyframes fadeSlideUp {
            from {
                opacity: 0;
                transform: translateY(16px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .welcome-icon {
            width: 4rem;
            height: 4rem;
            margin-bottom: 1.5rem;
            color: var(--teal-600);
            animation: fadeSlideUp 0.5s ease-out 0.1s both;
        }
        
        .welcome-icon svg {
            width: 100%;
            height: 100%;
        }

        .welcome-title {
            font-size: 1.5rem;
            font-weight: 700;
            letter-spacing: -0.02em;
            color: var(--gray-900);
            margin-bottom: 0.5rem;
            animation: fadeSlideUp 0.5s ease-out 0.2s both;
        }

        .welcome-subtitle {
            color: var(--gray-500);
            max-width: 400px;
            margin-bottom: 1.5rem;
            font-weight: 400;
            letter-spacing: 0.01em;
            opacity: 0.85;
            animation: fadeSlideUp 0.5s ease-out 0.3s both;
        }

        .quick-actions {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            justify-content: center;
            max-width: 500px;
            animation: fadeSlideUp 0.5s ease-out 0.4s both;
        }

        .quick-action {
            padding: 0.625rem 1rem;
            background: white;
            border: 1px solid var(--gray-200);
            border-radius: 9999px;
            color: var(--gray-600);
            font-size: 0.875rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .quick-action:hover {
            background: var(--gray-50);
            border-color: var(--teal-600);
            color: var(--teal-700);
            transform: translateY(-2px);
        }

        /* Interrupt modal */
        .interrupt-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(4px);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 100;
            animation: fadeIn 0.2s ease-out;
        }

        .interrupt-overlay.hidden {
            display: none;
        }

        .interrupt-modal {
            background: white;
            border-radius: 1rem;
            padding: 2.5rem;
            max-width: 600px;
            width: 90%;
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
            animation: slideUp 0.3s ease-out;
        }

        @keyframes slideUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .interrupt-icon {
            width: 4rem;
            height: 4rem;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 1.5rem;
            color: var(--gray-700);
        }

        .interrupt-icon svg {
            width: 100%;
            height: 100%;
        }

        .interrupt-title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 1rem;
            color: var(--gray-900);
        }

        .interrupt-message {
            color: var(--gray-700);
            margin-bottom: 1.5rem;
            font-size: 1rem;
            line-height: 1.6;
        }

        .interrupt-message-content {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }

        .interrupt-message p {
            margin: 0;
            line-height: 1.6;
        }

        .interrupt-message strong {
            color: var(--gray-900);
            font-weight: 600;
        }

        .interrupt-detail-row {
            display: flex;
            align-items: baseline;
            gap: 0.5rem;
            padding: 0.5rem 0;
            border-bottom: 1px solid var(--gray-200);
        }

        .interrupt-detail-row:last-child {
            border-bottom: none;
        }

        .interrupt-detail-label {
            font-weight: 600;
            color: var(--teal-700);
            min-width: 100px;
            font-size: 0.9375rem;
        }

        .interrupt-detail-value {
            color: var(--gray-900);
            font-weight: 500;
            flex: 1;
        }

        .interrupt-message-text {
            color: var(--gray-600);
            margin-top: 0.75rem;
            font-size: 0.9375rem;
            line-height: 1.6;
        }

        .interrupt-options {
            display: flex;
            gap: 1rem;
            margin-top: 1.5rem;
        }

        .interrupt-option {
            padding: 1rem 2rem;
            background: var(--gray-100);
            border: 1px solid var(--gray-200);
            border-radius: 9999px;
            color: var(--gray-600);
            font-size: 1.0625rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            flex: 1;
            min-width: 140px;
        }

        .interrupt-option:hover {
            background: var(--gray-50);
            border-color: var(--teal-600);
            color: var(--teal-700);
        }

        .interrupt-input-group {
            display: flex;
            gap: 0.75rem;
            margin-top: 1.5rem;
        }

        .interrupt-input-group.hidden {
            display: none;
        }

        .interrupt-input {
            flex: 1;
            padding: 0.875rem 1.25rem;
            border: 2px solid var(--gray-200);
            border-radius: 0.5rem;
            font-family: inherit;
            font-size: 1.0625rem;
            outline: none;
            transition: border-color 0.2s ease;
        }

        .interrupt-input:focus {
            border-color: var(--teal-600);
        }

        .interrupt-submit {
            padding: 0.875rem 1.75rem;
            background: linear-gradient(135deg, var(--teal-600), var(--teal-700));
            border: none;
            border-radius: 0.5rem;
            color: white;
            font-family: inherit;
            font-size: 1.0625rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .interrupt-submit:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px color-mix(in oklab, var(--teal-500) 40%, transparent);
        }

        /* Inline choice buttons (for non-modal interrupts) */
        .inline-choice-container {
            display: flex;
            gap: 0.75rem;
            margin-top: 1rem;
            flex-wrap: wrap;
        }

        .inline-choice-btn {
            padding: 0.75rem 1.5rem;
            border-radius: 9999px;
            font-family: inherit;
            font-size: 0.9375rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            border: 2px solid;
        }

        .inline-choice-btn.primary {
            background: linear-gradient(135deg, var(--teal-600), var(--teal-700));
            border-color: var(--teal-600);
            color: white;
        }

        .inline-choice-btn.primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px color-mix(in oklab, var(--teal-500) 40%, transparent);
        }

        .inline-choice-btn.secondary {
            background: white;
            border-color: var(--gray-300);
            color: var(--gray-600);
        }

        .inline-choice-btn.secondary:hover {
            border-color: var(--teal-600);
            color: var(--teal-700);
            transform: translateY(-2px);
        }

        .inline-choice-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none !important;
        }

        /* Input disabled state (during inline choice) */
        .input-wrapper.disabled {
            opacity: 0.6;
            pointer-events: none;
            background: var(--gray-100);
        }

        .input-wrapper.disabled .message-input {
            background: var(--gray-100);
        }

        .input-disabled-notice {
            text-align: center;
            color: var(--gray-500);
            font-size: 0.875rem;
            padding: 0.5rem;
            display: none;
        }

        .input-disabled-notice.visible {
            display: block;
        }

        /* Scrollbar */
        .messages-area::-webkit-scrollbar {
            width: 6px;
        }

        .messages-area::-webkit-scrollbar-track {
            background: transparent;
        }

        .messages-area::-webkit-scrollbar-thumb {
            background: var(--gray-300);
            border-radius: 3px;
        }

        .messages-area::-webkit-scrollbar-thumb:hover {
            background: var(--gray-400);
        }

        /* Hidden utility */
        .hidden {
            display: none !important;
        }

        /* Basic inline video thumbnail card inside assistant bubbles */
        .video-card {
            margin-top: 0.75rem;
            border-radius: 0.75rem;
            overflow: hidden;
            background: #000;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            width: 100%;
            max-width: 100%;
            aspect-ratio: 16 / 9;
            position: relative;
        }

        .video-card a {
            position: absolute;
            inset: 0;
            display: block;
            color: inherit;
            text-decoration: none;
        }

        .video-card img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            display: block;
            transform: scale(1.01);
            filter: saturate(1.05);
        }

        .video-card::after {
            content: '';
            position: absolute;
            inset: 0;
            background: linear-gradient(to top, rgba(0, 0, 0, 0.55), rgba(0, 0, 0, 0.05) 55%);
            pointer-events: none;
        }

        .video-card-play {
            position: absolute;
            inset: 0;
            display: grid;
            place-items: center;
            z-index: 2;
            pointer-events: none;
        }

        .video-card-play span {
            width: 64px;
            height: 64px;
            border-radius: 999px;
            background: rgba(0, 0, 0, 0.55);
            border: 1px solid rgba(255, 255, 255, 0.35);
            display: grid;
            place-items: center;
            backdrop-filter: blur(8px);
        }

        .video-card-play svg {
            width: 22px;
            height: 22px;
            margin-left: 2px;
            fill: white;
            opacity: 0.95;
        }

        .video-card:hover img {
            transform: scale(1.03);
            transition: transform 200ms ease;
        }

        .video-card:focus-within {
            outline: 3px solid color-mix(in oklab, var(--teal-500) 65%, transparent);
            outline-offset: 3px;
        }

        /* Video message wrapper with header/footer sections */
        .video-message-wrapper {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }

        .video-message-header {
            font-size: 1.05rem;
            line-height: 1.5;
            color: var(--gray-800);
        }

        .video-message-header .track-info {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 1.1rem;
        }

        .video-message-header .track-info .music-icon {
            color: var(--teal-600);
        }

        .video-message-header strong {
            color: var(--teal-700);
            font-weight: 600;
        }

        .video-message-footer {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            padding: 0.875rem 1rem;
            background: linear-gradient(135deg, var(--teal-50) 0%, color-mix(in oklab, var(--teal-100) 50%, white) 100%);
            border-radius: 0.75rem;
            border-left: 3px solid var(--teal-500);
        }

        .video-message-footer .status-line {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.9rem;
            color: var(--gray-600);
        }

        .video-message-footer .status-line.available {
            color: var(--teal-700);
        }

        .video-message-footer .status-line.unavailable {
            color: var(--gray-500);
        }

        .video-message-footer .status-line .status-icon {
            flex-shrink: 0;
        }

        .video-message-footer .cta-line {
            font-size: 0.95rem;
            font-weight: 500;
            color: var(--teal-700);
        }

        .video-message-footer .price-tag {
            display: inline-flex;
            align-items: center;
            gap: 0.25rem;
            padding: 0.2rem 0.5rem;
            background: var(--teal-600);
            color: white;
            border-radius: 0.375rem;
            font-weight: 600;
            font-size: 0.85rem;
        }

        /* mp4 fallback */
        .video-embed {
            margin-top: 0.75rem;
            border-radius: 0.75rem;
            overflow: hidden;
            background: #000;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            width: 100%;
            max-width: 100%;
        }

        .video-embed video {
            width: 100%;
            height: auto;
            display: block;
            border: 0;
        }

        .youtube-card {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border-radius: 0.75rem;
            color: inherit;
            text-decoration: none;
            cursor: pointer;
            white-space: normal;
        }

        .youtube-card img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            display: block;
            filter: saturate(1.05);
            transform: scale(1.01);
        }

        .youtube-card::after {
            content: '';
            position: absolute;
            inset: 0;
            background: linear-gradient(to top, rgba(0, 0, 0, 0.55), rgba(0, 0, 0, 0.05) 55%);
        }

        .youtube-card-play {
            position: absolute;
            inset: 0;
            display: grid;
            place-items: center;
            z-index: 2;
        }

        .youtube-card-play span {
            width: 64px;
            height: 64px;
            border-radius: 999px;
            background: rgba(0, 0, 0, 0.55);
            border: 1px solid rgba(255, 255, 255, 0.35);
            display: grid;
            place-items: center;
            backdrop-filter: blur(8px);
        }

        .youtube-card-play svg {
            width: 22px;
            height: 22px;
            margin-left: 2px;
            fill: white;
            opacity: 0.95;
        }

        .youtube-card-meta {
            position: absolute;
            left: 0;
            right: 0;
            bottom: 0;
            padding: 0.75rem 0.9rem;
            z-index: 2;
            display: flex;
            gap: 0.5rem;
            align-items: center;
            justify-content: space-between;
        }

        .youtube-card-meta .label {
            font-weight: 600;
            color: rgba(255, 255, 255, 0.92);
            font-size: 0.95rem;
            line-height: 1.15;
        }

        .youtube-card-meta .sub {
            margin-top: 0.15rem;
            color: rgba(255, 255, 255, 0.75);
            font-size: 0.8rem;
        }

        .youtube-card:hover img {
            transform: scale(1.03);
            transition: transform 200ms ease;
        }

        .youtube-card:focus-visible {
            outline: 3px solid color-mix(in oklab, var(--teal-500) 65%, transparent);
            outline-offset: 3px;
        }

        /* Links in messages */
        .message-link {
            color: var(--teal-600);
            text-decoration: underline;
            text-underline-offset: 2px;
            transition: color 0.15s ease;
        }

        .message-link:hover {
            color: var(--teal-700);
        }

        .message.user .message-link {
            color: rgba(255, 255, 255, 0.9);
        }

        .message.user .message-link:hover {
            color: white;
        }

        /* Beautiful styled tables for data display */
        .message-table {
            margin: 1rem 0;
            width: 100%;
            border-collapse: separate;
            border-spacing: 0;
            border-radius: 0.75rem;
            overflow: hidden;
            box-shadow: 
                0 1px 3px rgba(0, 0, 0, 0.08),
                0 4px 12px color-mix(in oklab, var(--teal-500) 12%, transparent);
            background: white;
            border: 1px solid var(--teal-200);
        }

        .message-table thead {
            background: linear-gradient(135deg, var(--teal-600) 0%, var(--teal-700) 100%);
            color: white;
        }

        .message-table thead th {
            padding: 0.875rem 1rem;
            text-align: left;
            font-weight: 600;
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            white-space: nowrap;
            border-bottom: 2px solid var(--teal-800);
        }

        .message-table thead th:first-child {
            padding-left: 1.25rem;
            border-top-left-radius: 0.625rem;
        }

        .message-table thead th:last-child {
            padding-right: 1.25rem;
            border-top-right-radius: 0.625rem;
        }

        .message-table tbody tr {
            border-bottom: 1px solid var(--gray-200);
            transition: background-color 0.15s ease;
        }

        .message-table tbody tr:nth-child(even) {
            background: var(--gray-50);
        }

        .message-table tbody tr:last-child {
            border-bottom: none;
        }

        .message-table tbody tr:last-child td:first-child {
            border-bottom-left-radius: 0.625rem;
        }

        .message-table tbody tr:last-child td:last-child {
            border-bottom-right-radius: 0.625rem;
        }

        .message-table tbody tr:hover {
            background: color-mix(in oklab, var(--teal-50) 60%, white);
        }

        .message-table tbody td {
            padding: 0.75rem 1rem;
            color: var(--gray-700);
            font-size: 0.9375rem;
            vertical-align: middle;
        }

        .message-table tbody td:first-child {
            padding-left: 1.25rem;
        }

        .message-table tbody td:last-child {
            padding-right: 1.25rem;
        }

        .message-table tbody td strong {
            color: var(--gray-900);
            font-weight: 600;
        }

        /* Column-specific styling */
        .message-table .table-number {
            color: var(--teal-700);
            font-weight: 700;
            font-size: 0.875rem;
            min-width: 2rem;
            text-align: center;
        }

        .message-table .table-price {
            color: var(--teal-700);
            font-weight: 700;
            font-size: 0.9375rem;
            white-space: nowrap;
        }

        .message-table .table-date {
            color: var(--gray-500);
            font-size: 0.875rem;
            white-space: nowrap;
        }

        .message-table .table-duration {
            color: var(--gray-500);
            font-size: 0.875rem;
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, monospace;
            white-space: nowrap;
        }

        .message-table .table-id {
            text-align: center;
        }

        .message-table .table-id .id-badge {
            color: var(--teal-600);
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, monospace;
            font-size: 0.8125rem;
            font-weight: 500;
            background: var(--teal-50);
            padding: 0.25rem 0.5rem;
            border-radius: 0.25rem;
            display: inline-block;
        }

        .message-table .table-label {
            color: var(--gray-600);
            font-size: 0.875rem;
            text-transform: capitalize;
            min-width: 100px;
        }

        /* Responsive table adjustments */
        @media (max-width: 640px) {
            .message-table {
                font-size: 0.875rem;
            }
            
            .message-table thead th,
            .message-table tbody td {
                padding: 0.625rem 0.75rem;
            }
            
            .message-table thead th:first-child,
            .message-table tbody td:first-child {
                padding-left: 0.875rem;
            }
            
            .message-table thead th:last-child,
            .message-table tbody td:last-child {
                padding-right: 0.875rem;
            }
        }
    </style>
</head>
<body>
    <div class="app-container">
        <div class="chat-wrapper">
            <!-- Header -->
            <header class="header">
                <div class="header-left">
                    <img class="logo-icon" src="/static/logo.png" alt="Langchain Music Store Logo">
                    <span class="header-title">Langchain Music Store</span>
                    <div class="status-indicator hidden" id="status-indicator"></div>
                </div>
                <button class="menu-button">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
                        <line x1="3" y1="12" x2="21" y2="12"/>
                        <line x1="3" y1="6" x2="21" y2="6"/>
                        <line x1="3" y1="18" x2="21" y2="18"/>
                    </svg>
                </button>
            </header>

            <!-- Messages -->
            <div class="messages-area" id="messages-area">
                <div class="messages-container" id="messages-container">
                    <!-- Welcome screen -->
                    <div class="welcome-screen" id="welcome-screen">
                        <div class="welcome-icon">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
                                <circle cx="8" cy="18" r="4"/>
                                <path d="M12 18V2l7 4"/>
                            </svg>
                        </div>
                        <h2 class="welcome-title">Welcome, Luís!</h2>
                        <p class="welcome-subtitle">I'm here to help you browse our catalog, manage your account, or find that song stuck in your head.</p>
                        <div class="quick-actions">
                            <button class="quick-action" data-message="What genres do you have?">Browse Genres</button>
                            <button class="quick-action" data-message="Show me my profile">My Account</button>
                            <button class="quick-action" data-message="Show me artists in Rock">Rock Artists</button>
                            <button class="quick-action" data-message="I remember lyrics: back in black I hit the sack">Find by Lyrics</button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Input -->
            <div class="input-area">
                <div class="input-container">
                    <div class="input-wrapper" id="input-wrapper">
                        <textarea 
                            class="message-input" 
                            id="message-input" 
                            placeholder="Send a message..."
                            rows="1"
                        ></textarea>
                        <button class="send-button" id="send-button">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <line x1="12" y1="19" x2="12" y2="5"/>
                                <polyline points="5 12 12 5 19 12"/>
                            </svg>
                        </button>
                    </div>
                    <p class="input-footer" id="input-footer">Press Enter to send, Shift+Enter for new line</p>
                    <p class="input-disabled-notice" id="input-disabled-notice">Please select an option above to continue</p>
                </div>
            </div>
        </div>
    </div>

    <!-- Interrupt Modal -->
    <div class="interrupt-overlay hidden" id="interrupt-overlay">
        <div class="interrupt-modal">
            <div class="interrupt-icon">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <rect x="6" y="4" width="4" height="16"/>
                    <rect x="14" y="4" width="4" height="16"/>
                </svg>
            </div>
            <h3 class="interrupt-title" id="interrupt-title">Input Required</h3>
            <p class="interrupt-message" id="interrupt-message">Please provide your response:</p>
            <div class="interrupt-options" id="interrupt-options"></div>
            <div class="interrupt-input-group hidden" id="interrupt-input-group">
                <input type="text" class="interrupt-input" id="interrupt-input" placeholder="Your response...">
                <button class="interrupt-submit" id="interrupt-submit">Submit</button>
            </div>
        </div>
    </div>

    <script>
        // Icons as SVG strings
        const icons = {
            music: `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M9 18V5l12-2v13"/><circle cx="6" cy="18" r="3"/><circle cx="18" cy="16" r="3"/></svg>`,
            user: `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"/><circle cx="12" cy="7" r="4"/></svg>`,
            wrench: `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M14.7 6.3a1 1 0 0 0 0 1.4l1.6 1.6a1 1 0 0 0 1.4 0l3.77-3.77a6 6 0 0 1-7.94 7.94l-6.91 6.91a2.12 2.12 0 0 1-3-3l6.91-6.91a6 6 0 0 1 7.94-7.94l-3.76 3.76z"/></svg>`,
            chevronDown: `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"/></svg>`,
            piano: `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M18.5 8c-1.4 0-2.6-.8-3.2-2A6.87 6.87 0 0 0 2 9v11a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2v-8.5C22 9.6 20.4 8 18.5 8"></path><path d="M2 14h20"></path><path d="M6 14v4"></path><path d="M10 14v4"></path><path d="M14 14v4"></path><path d="M18 14v4"></path></svg>`,
            drum: `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="m2 2 8 8"></path><path d="m22 2-8 8"></path><ellipse cx="12" cy="9" rx="10" ry="5"></ellipse><path d="M7 13.4v7.9"></path><path d="M12 14v8"></path><path d="M17 13.4v7.9"></path><path d="M2 9v8a10 5 0 0 0 20 0V9"></path></svg>`,
            micVocal: `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="m11 7.601-5.994 8.19a1 1 0 0 0 .1 1.298l.817.818a1 1 0 0 0 1.314.087L15.09 12"></path><path d="M16.5 21.174C15.5 20.5 14.372 20 13 20c-2.058 0-3.928 2.356-6 2-2.072-.356-2.775-3.369-1.5-4.5"></path><circle cx="16" cy="7" r="5"></circle></svg>`,
            audioLines: `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M2 10v3"></path><path d="M6 6v11"></path><path d="M10 3v18"></path><path d="M14 8v7"></path><path d="M18 5v13"></path><path d="M22 10v3"></path></svg>`,
            smartphone: `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><rect width="14" height="20" x="5" y="2" rx="2" ry="2"></rect><path d="M12 18h.01"></path></svg>`,
            checkCircle: `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"></path><polyline points="22 4 12 14.01 9 11.01"></polyline></svg>`,
            xCircle: `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><path d="m15 9-6 6"></path><path d="m9 9 6 6"></path></svg>`,
            info: `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><path d="M12 16v-4"></path><path d="M12 8h.01"></path></svg>`,
        };

        const loadingStates = [
            { icon: 'piano', text: 'Tuning...' },
            { icon: 'drum', text: 'Composing...' },
            { icon: 'micVocal', text: 'Orchestrating...' },
            { icon: 'audioLines', text: 'Harmonizing...' },
        ];

        const API_BASE = '';
        let sessionId = null;
        let currentRunId = null;
        let isProcessing = false;
        let loadingStateIndex = 0;
        let loadingInterval = null;
        let inlineChoiceActive = false;  // Track if we're waiting for inline choice
        // NOTE: Deduplication removed - graph-level Input/Output schemas now prevent duplicates
        // let seenMessageContents = new Set();

        // DOM Elements
        const messagesArea = document.getElementById('messages-area');
        const messagesContainer = document.getElementById('messages-container');
        const welcomeScreen = document.getElementById('welcome-screen');
        const messageInput = document.getElementById('message-input');
        const inputWrapper = document.getElementById('input-wrapper');
        const sendButton = document.getElementById('send-button');
        const statusIndicator = document.getElementById('status-indicator');
        const interruptOverlay = document.getElementById('interrupt-overlay');
        const interruptTitle = document.getElementById('interrupt-title');
        const interruptMessage = document.getElementById('interrupt-message');
        const interruptOptions = document.getElementById('interrupt-options');
        const interruptInputGroup = document.getElementById('interrupt-input-group');
        const interruptInput = document.getElementById('interrupt-input');
        const interruptSubmit = document.getElementById('interrupt-submit');
        const inputFooter = document.getElementById('input-footer');
        const inputDisabledNotice = document.getElementById('input-disabled-notice');

        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            // Quick action buttons
            document.querySelectorAll('.quick-action').forEach(btn => {
                btn.addEventListener('click', () => {
                    const message = btn.dataset.message;
                    messageInput.value = message;
                    sendMessage();
                });
            });

            // Send button
            sendButton.addEventListener('click', sendMessage);

            // Enter to send (Shift+Enter for newline)
            messageInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    sendMessage();
                }
            });

            // Input focus styling
            messageInput.addEventListener('focus', () => {
                inputWrapper.classList.add('focused');
            });

            messageInput.addEventListener('blur', () => {
                inputWrapper.classList.remove('focused');
            });

            // Auto-resize textarea and update button state
            messageInput.addEventListener('input', () => {
                messageInput.style.height = 'auto';
                messageInput.style.height = Math.min(messageInput.scrollHeight, 200) + 'px';
                updateSendButton();
            });

            // Interrupt handlers
            interruptSubmit.addEventListener('click', () => {
                const value = interruptInput.value.trim();
                if (value) {
                    submitInterrupt(value);
                }
            });
            interruptInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    const value = interruptInput.value.trim();
                    if (value) {
                        submitInterrupt(value);
                    }
                }
            });

        });

        function updateSendButton() {
            const hasContent = messageInput.value.trim().length > 0;
            if (hasContent) {
                sendButton.classList.add('active');
            } else {
                sendButton.classList.remove('active');
            }
        }

        async function sendMessage() {
            const message = messageInput.value.trim();
            if (!message || isProcessing) return;

            // Hide welcome screen
            welcomeScreen.classList.add('hidden');

            // Add user message
            addMessage('user', message);
            messageInput.value = '';
            messageInput.style.height = 'auto';
            updateSendButton();

            isProcessing = true;
            sendButton.classList.remove('active');
            statusIndicator.classList.remove('hidden');

            try {
                // Start chat
                const response = await fetch(`${API_BASE}/api/chat`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ session_id: sessionId, message })
                });

                const data = await response.json();
                sessionId = data.session_id;
                currentRunId = data.run_id;

                // Stream the response
                await streamResponse(data.run_id);
            } catch (error) {
                console.error('Error:', error);
                addMessage('assistant', 'Sorry, something went wrong. Please try again.');
            } finally {
                isProcessing = false;
                statusIndicator.classList.add('hidden');
                updateSendButton();
            }
        }

        async function streamResponse(runId) {
            // Add typing indicator
            const typingEl = addTypingIndicator();
            startLoadingAnimation();

            try {
                const response = await fetch(`${API_BASE}/api/stream/${runId}`);
                const reader = response.body.getReader();
                const decoder = new TextDecoder();

                let buffer = '';
                let currentNodeEl = null;
                let typingRemoved = false;
                let pendingResponseEl = null;  // "Waiting for response" indicator

                while (true) {
                    const { value, done } = await reader.read();
                    if (done) break;

                    buffer += decoder.decode(value, { stream: true });
                    const lines = buffer.split('\n');
                    buffer = lines.pop() || '';

                    for (const line of lines) {
                        if (line.startsWith('data: ')) {
                            const data = JSON.parse(line.slice(6));

                            switch (data.type) {
                                case 'node_start':
                                    // Hidden - keep typing indicator running
                                    break;

                                case 'node_end':
                                    // Hidden - keep typing indicator running
                                    break;

                                case 'tool_call':
                                    // NOW remove typing indicator - we have visible content
                                    if (!typingRemoved) {
                                        typingEl.remove();
                                        stopLoadingAnimation();
                                        typingRemoved = true;
                                    }
                                    // Remove any pending response indicator first
                                    if (pendingResponseEl) {
                                        pendingResponseEl.remove();
                                        pendingResponseEl = null;
                                    }
                                    // Show tool calls with nice accordion UI
                                    addToolCall(data.name, data.args);
                                    break;

                                case 'tool_result':
                                    // Show tool results in the accordion
                                    addToolResult(data.name, data.content);
                                    // Add "waiting for response" indicator below - Claude-style UX
                                    if (!pendingResponseEl) {
                                        pendingResponseEl = addPendingResponseIndicator();
                                    }
                                    break;

                                case 'message':
                                    // Remove typing indicator if still showing (direct response, no tools)
                                    if (!typingRemoved) {
                                        typingEl.remove();
                                        stopLoadingAnimation();
                                        typingRemoved = true;
                                    }
                                    // Remove the pending indicator immediately (no delay to avoid gap)
                                    if (pendingResponseEl) {
                                        pendingResponseEl.remove();
                                        pendingResponseEl = null;
                                    }
                                    // Show the complete message
                                    addMessage('assistant', data.content);
                                    break;

                                case 'interrupt':
                                    // Remove typing indicator if still showing
                                    if (!typingRemoved) {
                                        typingEl.remove();
                                        stopLoadingAnimation();
                                        typingRemoved = true;
                                    }
                                    // Clean up pending indicator before interrupt
                                    if (pendingResponseEl) {
                                        pendingResponseEl.remove();
                                        pendingResponseEl = null;
                                    }
                                    showInterrupt(data.data);
                                    return;

                                case 'error':
                                    // Remove typing indicator if still showing
                                    if (!typingRemoved) {
                                        typingEl.remove();
                                        stopLoadingAnimation();
                                        typingRemoved = true;
                                    }
                                    // Clean up pending indicator on error
                                    if (pendingResponseEl) {
                                        pendingResponseEl.remove();
                                        pendingResponseEl = null;
                                    }
                                    addMessage('assistant', `Error: ${data.message}`);
                                    break;

                                case 'done':
                                    // Clean up any remaining pending indicator
                                    if (pendingResponseEl) {
                                        pendingResponseEl.remove();
                                        pendingResponseEl = null;
                                    }
                                    break;
                            }
                        }
                    }
                }

                if (!typingRemoved) {
                    typingEl.remove();
                    stopLoadingAnimation();
                }
            } catch (error) {
                console.error('Stream error:', error);
                typingEl.remove();
                stopLoadingAnimation();
                // Clean up any pending response indicator
                const pendingEl = document.querySelector('.pending-response-indicator');
                if (pendingEl) pendingEl.remove();
                addMessage('assistant', 'Connection lost. Please try again.');
            }
        }

        function addMessage(role, content) {
            const messageEl = document.createElement('div');
            messageEl.className = `message ${role}`;
            
            const avatarIcon = role === 'user' ? icons.user : icons.music;

            messageEl.innerHTML = `
                <div class="message-avatar">${avatarIcon}</div>
                <div class="message-content">
                    <div class="message-bubble"></div>
                </div>
            `;

            const bubbleEl = messageEl.querySelector('.message-bubble');
            if (bubbleEl) {
                renderMessageBubble(bubbleEl, role, content);
            }
            
            messagesContainer.appendChild(messageEl);
            scrollToBottom();
            return messageEl;
        }

        function addTypingIndicator() {
            const el = document.createElement('div');
            el.className = 'typing-indicator';
            el.id = 'typing-indicator';
            el.innerHTML = `
                <div class="typing-avatar">${icons.music}</div>
                <div class="typing-content">
                    <div class="typing-icon" id="typing-icon">${icons.piano}</div>
                    <span class="typing-text" id="typing-text">Tuning...</span>
                    <div class="typing-dots">
                        <div class="typing-dot"></div>
                        <div class="typing-dot"></div>
                        <div class="typing-dot"></div>
                    </div>
                </div>
            `;
            messagesContainer.appendChild(el);
            scrollToBottom();
            return el;
        }

        function startLoadingAnimation() {
            loadingStateIndex = 0;
            loadingInterval = setInterval(() => {
                loadingStateIndex = (loadingStateIndex + 1) % loadingStates.length;
                const state = loadingStates[loadingStateIndex];
                const iconEl = document.getElementById('typing-icon');
                const textEl = document.getElementById('typing-text');
                if (iconEl && textEl) {
                    iconEl.innerHTML = icons[state.icon];
                    textEl.textContent = state.text;
                }
            }, 800);
        }

        function stopLoadingAnimation() {
            if (loadingInterval) {
                clearInterval(loadingInterval);
                loadingInterval = null;
            }
        }

        // Claude-style "waiting for response" indicator that appears after tool calls
        // Uses same style as typing indicator for consistency
        function addPendingResponseIndicator() {
            const el = document.createElement('div');
            el.className = 'typing-indicator pending-response-indicator';
            el.innerHTML = `
                <div class="typing-avatar">${icons.music}</div>
                <div class="typing-content">
                    <div class="typing-icon">${icons.audioLines}</div>
                    <span class="typing-text">Composing...</span>
                    <div class="typing-dots">
                        <div class="typing-dot"></div>
                        <div class="typing-dot"></div>
                        <div class="typing-dot"></div>
                    </div>
                </div>
            `;
            messagesContainer.appendChild(el);
            scrollToBottom();
            return el;
        }

        function addNodeIndicator(nodeName, active = false) {
            const el = document.createElement('div');
            el.className = `node-indicator ${active ? 'active' : ''}`;
            el.innerHTML = `
                ${active ? '<div class="node-dot"></div>' : ''}
                <span>${formatNodeName(nodeName)}</span>
            `;
            messagesContainer.appendChild(el);
            scrollToBottom();
            return el;
        }

        function addToolCall(name, args) {
            const id = 'tool-' + Date.now();
            const el = document.createElement('div');
            el.className = 'message assistant';
            
            const argsStr = Object.entries(args || {})
                .filter(([k]) => k !== 'config')
                .map(([k, v]) => `${k}: ${JSON.stringify(v)}`)
                .join('\n');
            
            el.innerHTML = `
                <div class="message-avatar">${icons.music}</div>
                <div class="message-content">
                    <div class="tool-container">
                        <button class="tool-header" onclick="toggleTool('${id}')">
                            <div class="tool-header-left">
                                ${icons.wrench}
                                <span class="tool-name">${name}</span>
                            </div>
                            <div class="tool-chevron" id="${id}-chevron">${icons.chevronDown}</div>
                        </button>
                        <div class="tool-content" id="${id}-content">
                            <div class="tool-content-inner">
                                <div class="tool-section">
                                    <div class="tool-section-label">Input:</div>
                                    <pre class="tool-section-content">${escapeHtml(argsStr || 'No arguments')}</pre>
                                </div>
                                <div class="tool-section" id="${id}-output" style="display: none;">
                                    <div class="tool-section-label">Output:</div>
                                    <pre class="tool-section-content" id="${id}-output-content"></pre>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            `;
            
            messagesContainer.appendChild(el);
            scrollToBottom();
            
            // Store reference for adding output later
            window.lastToolId = id;
        }

        function addToolResult(name, content) {
            const id = window.lastToolId;
            if (id) {
                const outputSection = document.getElementById(`${id}-output`);
                const outputContent = document.getElementById(`${id}-output-content`);
                if (outputSection && outputContent) {
                    outputSection.style.display = 'block';
                    outputContent.textContent = content;
                }
            }
        }

        window.toggleTool = function(id) {
            const content = document.getElementById(`${id}-content`);
            const chevron = document.getElementById(`${id}-chevron`);
            if (content && chevron) {
                content.classList.toggle('expanded');
                chevron.classList.toggle('expanded');
            }
        };

        function formatInterruptMessage(message) {
            if (!message) return '';
            
            // Pattern to match structured data like "**Track:** 2 A.M. **Track ID:** 1404 **Price:** $0.99"
            const detailPattern = /\*\*([^:]+?):\*\*\s*([^*\n]+?)(?=\s*\*\*|$)/g;
            const matches = Array.from(message.matchAll(detailPattern));
            
            // If we have structured data, format it nicely
            if (matches.length > 0) {
                const details = [];
                let remainingText = message;
                
                matches.forEach(match => {
                    const label = match[1].trim();
                    const value = match[2].trim();
                    details.push({ label, value });
                    remainingText = remainingText.replace(match[0], '');
                });
                
                // Clean up remaining text (remove extra spaces, newlines)
                remainingText = remainingText
                    .replace(/\n+/g, ' ')
                    .replace(/\s+/g, ' ')
                    .trim();
                
                let html = '';
                
                // Add details in a structured format
                if (details.length > 0) {
                    html += '<div class="interrupt-message-content">';
                    details.forEach(detail => {
                        html += `
                            <div class="interrupt-detail-row">
                                <span class="interrupt-detail-label">${escapeHtml(detail.label)}</span>
                                <span class="interrupt-detail-value">${escapeHtml(detail.value)}</span>
                            </div>
                        `;
                    });
                    html += '</div>';
                }
                
                // Add any remaining text (process markdown bold)
                if (remainingText) {
                    const formattedText = escapeHtml(remainingText).replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>');
                    html += `<p class="interrupt-message-text">${formattedText}</p>`;
                }
                
                return html;
            }
            
            // If no structured data, just format the text with markdown-style bold
            return message
                .replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>')
                .replace(/\n/g, '<br>');
        }

        function showInterrupt(data) {
            const interruptType = data.type || 'confirm';
            
            // For "choice" type, render inline buttons in chat instead of modal
            if (interruptType === 'choice') {
                showInlineChoice(data);
                return;
            }
            
            // For other types (confirm, input), use the modal
            interruptTitle.textContent = data.title || 'Input Required';
            
            // Format the message with better styling
            const message = data.message || 'Please provide your response:';
            interruptMessage.innerHTML = formatInterruptMessage(message);
            
            // Clear previous state
            interruptOptions.innerHTML = '';
            interruptInput.value = '';
            
            if (interruptType === 'input') {
                // Show input field, hide buttons
                interruptInputGroup.classList.remove('hidden');
                interruptOptions.style.display = 'none';
                interruptInput.focus();
            } else {
                // Show buttons, hide input field
                interruptInputGroup.classList.add('hidden');
                interruptOptions.style.display = 'flex';
                
                // Populate buttons from options (handle both string[] and object[] formats)
                if (data.options && data.options.length > 0) {
                    data.options.forEach(option => {
                        const btn = document.createElement('button');
                        btn.className = 'interrupt-option';
                        // Support both {value, label} objects and plain strings
                        const optValue = typeof option === 'object' ? option.value : option;
                        const optLabel = typeof option === 'object' ? option.label : option;
                        btn.textContent = optLabel;
                        btn.addEventListener('click', () => {
                            submitInterrupt(optValue);
                        });
                        interruptOptions.appendChild(btn);
                    });
                }
            }
            
            interruptOverlay.classList.remove('hidden');
        }

        function showInlineChoice(data) {
            // Render choice buttons inline in the chat, not as a modal
            const message = data.message || 'Please choose an option:';
            
            // Create a message element with inline buttons
            const messageEl = document.createElement('div');
            messageEl.className = 'message assistant';
            messageEl.id = 'inline-choice-message';
            
            messageEl.innerHTML = `
                <div class="message-avatar">${icons.music}</div>
                <div class="message-content">
                    <div class="message-bubble">
                        <div class="inline-choice-container" id="inline-choice-buttons"></div>
                    </div>
                </div>
            `;
            
            // Use the same rendering logic as regular messages
            const bubbleEl = messageEl.querySelector('.message-bubble');
            const buttonContainer = messageEl.querySelector('#inline-choice-buttons');
            
            // Render the message content with video support, then append buttons
            renderInlineChoiceContent(bubbleEl, message, buttonContainer);
            
            messagesContainer.appendChild(messageEl);
            
            // Add the buttons
            if (data.options && data.options.length > 0) {
                data.options.forEach(option => {
                    const btn = document.createElement('button');
                    // Support both {value, label, style} objects and plain strings
                    const optValue = typeof option === 'object' ? option.value : option;
                    const optLabel = typeof option === 'object' ? option.label : option;
                    const optStyle = typeof option === 'object' ? (option.style || 'secondary') : 'secondary';
                    
                    btn.className = `inline-choice-btn ${optStyle}`;
                    btn.textContent = optLabel;
                    btn.addEventListener('click', () => {
                        handleInlineChoice(optValue, buttonContainer);
                    });
                    buttonContainer.appendChild(btn);
                });
            }
            
            // Disable input while waiting for choice
            setInputDisabled(true);
            
            scrollToBottom();
        }

        function renderInlineChoiceContent(bubbleEl, content, buttonContainer) {
            // Render content with YouTube video support, then ensure buttons are at the end
            const raw = String(content ?? '');
            
            // Detect YouTube URLs
            const ytRegex = /https?:\/\/(?:www\.)?(?:youtube\.com\/embed\/|youtube\.com\/watch\?v=|youtu\.be\/)([a-zA-Z0-9_-]{11})(?:[^\s]*)?/i;
            const ytMatch = raw.match(ytRegex);
            
            if (ytMatch) {
                // Has video - create structured layout
                const wrapper = document.createElement('div');
                wrapper.className = 'video-message-wrapper';
                
                // Get text without the URL
                let textContent = raw.replace(ytMatch[0], '').trim();
                
                // Split at "Here's a video" to get header and footer
                const videoIntroMatch = textContent.match(/^(.*?)(?:Here'?s a video[^:]*:?\s*)/i);
                let headerText = '';
                let footerText = '';
                
                if (videoIntroMatch) {
                    headerText = videoIntroMatch[1].trim();
                    footerText = textContent.slice(videoIntroMatch[0].length).trim();
                } else {
                    // Try splitting at common patterns
                    const splitMatch = textContent.match(/^(.*?(?:by\s+\*\*[^*]+\*\*[!.]?))/i);
                    if (splitMatch) {
                        headerText = splitMatch[1].trim();
                        footerText = textContent.slice(splitMatch[0].length).trim();
                    } else {
                        headerText = textContent;
                    }
                }
                
                // Create header
                if (headerText) {
                    const header = document.createElement('div');
                    header.className = 'video-message-header';
                    let headerHtml = headerText
                        .replace(/🎵\s*/g, '')
                        .replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>')
                        .replace(/\n/g, '<br>');
                    header.innerHTML = `<div class="track-info"><span class="music-icon">${icons.music}</span> ${headerHtml}</div>`;
                    wrapper.appendChild(header);
                }
                
                // Add video thumbnail
                wrapper.appendChild(createYouTubeThumbnailCard(ytMatch[1], ytMatch[0]));
                
                // Create footer
                if (footerText) {
                    const footer = document.createElement('div');
                    footer.className = 'video-message-footer';
                    let footerHtml = footerText
                        .replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>')
                        .replace(/\n/g, '<br>');
                    footer.innerHTML = footerHtml;
                    wrapper.appendChild(footer);
                }
                
                // Insert wrapper before buttons
                bubbleEl.insertBefore(wrapper, buttonContainer);
                
                // Mark parent as having video for wider layout
                const contentEl = bubbleEl.closest('.message-content');
                if (contentEl) contentEl.classList.add('has-video');
            } else {
                // No video - simple text with markdown
                const textEl = document.createElement('div');
                textEl.className = 'message-text';
                textEl.innerHTML = raw
                    .replace(/🎵\s*/g, '<span class="music-icon">' + icons.music + '</span> ')
                    .replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>')
                    .replace(/\n/g, '<br>');
                bubbleEl.insertBefore(textEl, buttonContainer);
            }
        }

        async function handleInlineChoice(value, buttonContainer) {
            // Disable all buttons to prevent double-click
            const buttons = buttonContainer.querySelectorAll('.inline-choice-btn');
            buttons.forEach(btn => btn.disabled = true);
            
            // Re-enable input
            setInputDisabled(false);
            
            // Show the user's response
            addMessage('user', value);

            statusIndicator.classList.remove('hidden');

            try {
                // Resume the interrupt
                await fetch(`${API_BASE}/api/interrupt/${currentRunId}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ resume_value: value })
                });

                // Continue streaming
                await streamResponse(currentRunId);
            } catch (error) {
                console.error('Inline choice error:', error);
                addMessage('assistant', 'Error resuming. Please try again.');
                // Re-enable buttons on error
                buttons.forEach(btn => btn.disabled = false);
                setInputDisabled(true);
            } finally {
                statusIndicator.classList.add('hidden');
            }
        }

        function setInputDisabled(disabled) {
            inlineChoiceActive = disabled;
            if (disabled) {
                inputWrapper.classList.add('disabled');
                messageInput.disabled = true;
                sendButton.disabled = true;
                inputFooter.style.display = 'none';
                inputDisabledNotice.classList.add('visible');
            } else {
                inputWrapper.classList.remove('disabled');
                messageInput.disabled = false;
                sendButton.disabled = false;
                inputFooter.style.display = 'block';
                inputDisabledNotice.classList.remove('visible');
            }
        }

        async function submitInterrupt(value) {
            if (!value) return;

            interruptOverlay.classList.add('hidden');

            // Show the user's response
            addMessage('user', value);

            statusIndicator.classList.remove('hidden');

            try {
                // Resume the interrupt
                await fetch(`${API_BASE}/api/interrupt/${currentRunId}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ resume_value: value })
                });

                // Continue streaming
                await streamResponse(currentRunId);
            } catch (error) {
                console.error('Interrupt error:', error);
                addMessage('assistant', 'Error resuming. Please try again.');
            } finally {
                statusIndicator.classList.add('hidden');
            }
        }

        function scrollToBottom() {
            messagesArea.scrollTop = messagesArea.scrollHeight;
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        /**
         * Unified Data Parser - Detects and extracts structured data from LLM responses
         * Uses a priority-based detection system with flexible pattern matching
         */
        function parseListToTable(content) {
            if (!content || typeof content !== 'string') {
                return { tableData: null, tableType: null, remaining: content || '' };
            }

            const raw = content.replace(/\r\n/g, '\n');
            
            // Helper: extract price value, normalizing format
            const normalizePrice = (val) => {
                if (!val) return '';
                const num = String(val).replace(/[^0-9.]/g, '');
                return num ? `$${parseFloat(num).toFixed(2)}` : '';
            };

            // Helper: format duration from various formats (seconds, mm:ss, etc.)
            const normalizeDuration = (val) => {
                if (!val) return '';
                const str = String(val).trim();
                // If already in mm:ss format
                if (/^\d+:\d{2}$/.test(str)) return str;
                // If in seconds, convert
                const secs = parseInt(str, 10);
                if (!isNaN(secs)) {
                    const mins = Math.floor(secs / 60);
                    const remainSecs = secs % 60;
                    return `${mins}:${remainSecs.toString().padStart(2, '0')}`;
                }
                return str;
            };

            // Helper: clean markdown bold from text
            const cleanBold = (text) => String(text || '').replace(/\*\*/g, '').trim();

            // ========== DETECTION STRATEGIES (ordered by specificity) ==========

            // Strategy 1: Track blocks with bullet details
            // Format:
            // 1. **Track Name**
            //    - TrackId: 123
            //    - Duration: 234
            //    - Price: $0.99
            function detectTrackBlocks() {
                const lines = raw.split('\n');
                const rows = [];
                const kept = [];
                let i = 0;

                while (i < lines.length) {
                    const line = lines[i];
                    const headerMatch = line.match(/^\s*(\d+)\.\s+\*?\*?(.+?)\*?\*?\s*$/);
                    
                    if (!headerMatch) {
                        kept.push(line);
                        i++;
                        continue;
                    }

                    const number = headerMatch[1];
                    // Strip price from track name if present (e.g. "Song - $0.99" -> "Song")
                    const name = cleanBold(headerMatch[2]).replace(/\s*[-–]\s*\$[\d.]+\s*$/, '').trim();
                    
                    // Look for bullet details
                    let j = i + 1;
                    while (j < lines.length && lines[j].trim() === '') j++;
                    
                    const details = {};
                    let foundDetails = false;

                    while (j < lines.length) {
                        const bulletLine = lines[j];
                        if (/^\s*\d+\./.test(bulletLine)) break; // Next numbered item
                        
                        const bulletMatch = bulletLine.match(/^\s*[-•]\s*\*?\*?([^:*]+)\*?\*?\s*:\s*(.+?)\s*$/);
                        if (!bulletMatch) {
                            if (bulletLine.trim() !== '') break;
                            j++;
                            continue;
                        }

                        foundDetails = true;
                        const key = bulletMatch[1].trim().toLowerCase().replace(/\s+/g, '');
                        const value = cleanBold(bulletMatch[2]);

                        if (key === 'trackid' || key === 'id') details.trackId = value;
                        else if (key === 'duration' || key === 'length') details.duration = normalizeDuration(value);
                        else if (key === 'price' || key === 'unitprice') details.price = normalizePrice(value);
                        else if (key === 'artist') details.artist = value;
                        else if (key === 'album') details.album = value;
                        else if (key === 'genre') details.genre = value;

                        j++;
                        while (j < lines.length && lines[j].trim() === '') j++;
                    }

                    if (foundDetails && (details.trackId || details.price)) {
                        rows.push({ number, name, ...details });
                        i = j;
                    } else {
                        kept.push(line);
                        i++;
                    }
                }

                if (rows.length > 0) {
                    return { tableData: rows, tableType: 'tracks', remaining: kept.join('\n').trim() };
                }
                return null;
            }

            // Strategy 2: Inline track format
            // Format: "1. **Song Name** - TrackId: 123, Price: $0.99" or variations
            function detectInlineTracks() {
                const patterns = [
                    // "1. **Song** - TrackId: 123, Price: $0.99"
                    /(\d+)\.\s+\*\*([^*]+)\*\*\s*[-–]\s*TrackId:\s*(\d+)(?:,\s*Price:\s*\$?([\d.]+))?/gi,
                    // "1. Song Name (TrackId: 123, $0.99)" - handles names with parens like "Song(2)"
                    /(\d+)\.\s+(.+?)\s*\(TrackId:\s*(\d+)(?:,?\s*\$?([\d.]+))?\)/gi,
                    // "- **Track:** Song **ID:** 123 **Price:** $0.99"
                    /[-•]\s*\*\*Track:\*\*\s*([^*\n]+?)(?:\s*\*\*(?:Track\s*)?ID:\*\*\s*(\d+))?(?:\s*\*\*Price:\*\*\s*\$?([\d.]+))?/gi,
                ];

                for (const pattern of patterns) {
                    const matches = Array.from(raw.matchAll(pattern));
                    if (matches.length >= 1) {
                        let remaining = raw;
                        const rows = matches.map((m, idx) => {
                            remaining = remaining.replace(m[0], '');
                            // Extract price from track name if not captured (e.g. "Song - $0.99")
                            let trackName = cleanBold(m[2] || m[1]);
                            let price = m[4] ? normalizePrice(m[4]) : '';
                            if (!price) {
                                const priceInName = trackName.match(/\$\s*([\d.]+)/);
                                if (priceInName) price = normalizePrice(priceInName[1]);
                            }
                            // Strip price from track name (e.g. "Song - $0.99" -> "Song")
                            trackName = trackName.replace(/\s*[-–]\s*\$[\d.]+\s*$/, '').trim();
                            return {
                                number: m[1] || String(idx + 1),
                                name: trackName,
                                trackId: m[3] || m[2] || '',
                                price
                            };
                        });
                        return { tableData: rows, tableType: 'tracks', remaining: remaining.trim() };
                    }
                }
                return null;
            }

            // Strategy 3: Purchase history / Invoices
            // Handles many LLM output formats for invoice data
            function detectPurchaseHistory() {
                // Helper to normalize date format
                const normalizeDate = (dateStr) => {
                    if (!dateStr) return '';
                    // Remove time portion if present (e.g., "2025-08-07 00:00:00" -> "2025-08-07")
                    return String(dateStr).replace(/\s+\d{2}:\d{2}:\d{2}/, '').trim();
                };

                // Strategy 3a: Split format - Invoice IDs listed separately from Date/Total
                // Handles format like:
                // Invoice ID    382
                // Billing Address    ...
                // ...
                // 1.
                //    - **Date:** 2025-08-07
                //    - **Total:** $8.91
                function detectSplitInvoiceFormat() {
                    // First, extract Invoice IDs from the header section
                    const invoiceIdPattern = /(?:Invoice\s*ID|InvoiceId)[:\s\t]+(\d+)/gi;
                    const invoiceIds = Array.from(raw.matchAll(invoiceIdPattern)).map(m => m[1]);
                    
                    if (invoiceIds.length === 0) return null;

                    // Now look for numbered items with Date/Total bullets
                    const lines = raw.split('\n');
                    const dateItems = [];
                    let i = 0;

                    while (i < lines.length) {
                        const line = lines[i];
                        // Match empty numbered item: "1." or "1. " (with nothing after)
                        const emptyNumMatch = line.match(/^\s*(\d+)\.\s*$/);
                        
                        if (!emptyNumMatch) {
                            i++;
                            continue;
                        }

                        const itemNumber = parseInt(emptyNumMatch[1], 10);
                        
                        // Look for bullet details
                        let j = i + 1;
                        while (j < lines.length && lines[j].trim() === '') j++;
                        
                        const details = {};
                        let foundDetails = false;

                        while (j < lines.length) {
                            const bulletLine = lines[j];
                            if (/^\s*\d+\.\s*$/.test(bulletLine)) break; // Next numbered item
                            
                            const bulletMatch = bulletLine.match(/^\s*[-•]\s*\*?\*?([^:*]+)\*?\*?\s*:\s*(.+?)\s*$/);
                            if (!bulletMatch) {
                                if (bulletLine.trim() !== '' && !/^\s*$/.test(bulletLine)) break;
                                j++;
                                continue;
                            }

                            foundDetails = true;
                            const key = bulletMatch[1].trim().toLowerCase().replace(/\s+/g, '');
                            const value = cleanBold(bulletMatch[2]);

                            if (key === 'date' || key === 'invoicedate') details.date = normalizeDate(value);
                            else if (key === 'total' || key === 'amount') details.total = normalizePrice(value);

                            j++;
                        }

                        if (foundDetails && (details.date || details.total)) {
                            dateItems.push({ itemNumber, ...details });
                        }
                        i = j;
                    }

                    // Combine Invoice IDs with Date/Total items
                    if (dateItems.length > 0 && invoiceIds.length >= dateItems.length) {
                        const rows = dateItems.map((item, idx) => ({
                            number: String(item.itemNumber),
                            invoiceId: invoiceIds[idx] || '',
                            date: item.date || '',
                            total: item.total || ''
                        }));

                        // Remove the matched content
                        let remaining = raw;
                        // Remove Invoice ID lines
                        remaining = remaining.replace(/(?:Invoice\s*ID|InvoiceId)[:\s\t]+\d+[^\n]*/gi, '');
                        // Remove Billing Address lines
                        remaining = remaining.replace(/Billing\s*Address[:\s\t]+[^\n]*/gi, '');
                        // Remove the numbered items with bullets
                        remaining = remaining.replace(/\d+\.\s*\n(?:\s*[-•]\s*\*?\*?[^:*]+\*?\*?\s*:\s*.+?\s*\n?)+/g, '');
                        remaining = remaining.replace(/\n{3,}/g, '\n\n').trim();
                        
                        return { tableData: rows, tableType: 'invoices', remaining };
                    }
                    return null;
                }

                // Strategy 3b: Block format - numbered items with invoice ID and bullet sub-details
                // 1. **Invoice 382**
                //    - Date: 2025-08-07
                //    - Total: $8.91
                function detectInvoiceBlocks() {
                    const lines = raw.split('\n');
                    const rows = [];
                    const kept = [];
                    let i = 0;

                    while (i < lines.length) {
                        const line = lines[i];
                        // Match multiple formats:
                        // "1. **Invoice 382**" or "1. **Invoice ID:** 382" or "1. Invoice #382" or "1. Invoice ID: 382"
                        const headerMatch = line.match(/^\s*(\d+)\.\s+(?:\*\*)?Invoice\s*(?:#|ID)?(?::\*\*|:)?\s*(\d+)(?:\*\*)?\s*$/i);
                        
                        if (!headerMatch) {
                            kept.push(line);
                            i++;
                            continue;
                        }

                        const number = headerMatch[1];
                        const invoiceId = headerMatch[2];
                        
                        // Look for bullet details
                        let j = i + 1;
                        while (j < lines.length && lines[j].trim() === '') j++;
                        
                        const details = { invoiceId };
                        let foundDetails = false;

                        while (j < lines.length) {
                            const bulletLine = lines[j];
                            if (/^\s*\d+\./.test(bulletLine)) break;
                            
                            const bulletMatch = bulletLine.match(/^\s*[-•]\s*\*?\*?([^:*]+)\*?\*?\s*:\s*(.+?)\s*$/);
                            if (!bulletMatch) {
                                if (bulletLine.trim() !== '') break;
                                j++;
                                continue;
                            }

                            foundDetails = true;
                            const key = bulletMatch[1].trim().toLowerCase().replace(/\s+/g, '');
                            const value = cleanBold(bulletMatch[2]);

                            if (key === 'date' || key === 'invoicedate') details.date = normalizeDate(value);
                            else if (key === 'total' || key === 'amount') details.total = normalizePrice(value);
                            else if (key === 'city' || key === 'billingcity') details.city = value;
                            else if (key === 'country' || key === 'billingcountry') details.country = value;

                            j++;
                            while (j < lines.length && lines[j].trim() === '') j++;
                        }

                        if (foundDetails && (details.date || details.total)) {
                            rows.push({ number, ...details });
                            i = j;
                        } else {
                            kept.push(line);
                            i++;
                        }
                    }

                    if (rows.length > 0) {
                        return { tableData: rows, tableType: 'invoices', remaining: kept.join('\n').trim() };
                    }
                    return null;
                }

                // Strategy 3c: Inline formats with regex patterns
                const inlinePatterns = [
                    // "1. **Invoice ID:** 382 - **Date:** 2025-08-07 - **Total:** $8.91"
                    /(\d+)\.\s+\*\*Invoice\s*(?:ID)?:\*\*\s*(\d+)\s*[-–]\s*\*\*Date:\*\*\s*([^\s*-]+(?:\s+[\d:]+)?)\s*[-–]\s*\*\*Total:\*\*\s*\$?([\d.]+)/gi,
                    // "1. Invoice 382 - Date: 2025-08-07 - Total: $8.91"
                    /(\d+)\.\s+Invoice\s*#?(\d+)\s*[-–]\s*Date:\s*([^\s-]+(?:\s+[\d:]+)?)\s*[-–]\s*Total:\s*\$?([\d.]+)/gi,
                    // "1. Invoice #382 (2025-08-07) - $8.91"
                    /(\d+)\.\s+Invoice\s*#?(\d+)\s*\(([^)]+)\)\s*[-–]\s*\$?([\d.]+)/gi,
                    // "- Invoice 382: Date 2025-08-07, Total $8.91"
                    /[-•]\s*Invoice\s*#?(\d+):\s*Date\s+([^\s,]+(?:\s+[\d:]+)?),?\s*Total\s*\$?([\d.]+)/gi,
                    // "Invoice ID: 382 | Date: 2025-08-07 | Total: $8.91"
                    /Invoice\s*(?:ID)?:\s*(\d+)\s*\|\s*Date:\s*([^\s|]+(?:\s+[\d:]+)?)\s*\|\s*Total:\s*\$?([\d.]+)/gi,
                ];

                // Try split format first (most specific for this edge case)
                const splitResult = detectSplitInvoiceFormat();
                if (splitResult) return splitResult;

                // Try block format
                const blockResult = detectInvoiceBlocks();
                if (blockResult) return blockResult;

                // Try inline patterns
                for (const pattern of inlinePatterns) {
                    const matches = Array.from(raw.matchAll(pattern));
                    if (matches.length >= 1) {
                        let remaining = raw;
                        const rows = matches.map((m, idx) => {
                            remaining = remaining.replace(m[0], '');
                            // Different patterns have different group positions
                            const hasNumberPrefix = m[1] && /^\d+$/.test(m[1]) && m[2];
                            const invoiceId = hasNumberPrefix ? m[2] : m[1];
                            const date = hasNumberPrefix ? m[3] : m[2];
                            const total = hasNumberPrefix ? m[4] : m[3];
                            return {
                                number: String(idx + 1),
                                invoiceId,
                                date: normalizeDate(date),
                                total: normalizePrice(total)
                            };
                        });
                        return { tableData: rows, tableType: 'invoices', remaining: remaining.trim() };
                    }
                }
                return null;
            }

            // Strategy 4: Invoice line items / purchase details
            // Handles multiple formats for invoice line item display
            function detectInvoiceLineItems() {
                // Strategy 4a: Block format - track name on its own line, details as bullets
                // Format:
                // Track Name (or **Track Name**)
                // - **Artist:** Artist
                // - **Album:** Album
                // - **Unit Price:** $0.99
                // - **Quantity:** 1
                function detectInvoiceItemBlocks() {
                    const lines = raw.split('\n');
                    const rows = [];
                    const kept = [];
                    let i = 0;

                    while (i < lines.length) {
                        const line = lines[i];
                        
                        // Skip empty lines
                        if (line.trim() === '') {
                            kept.push(line);
                            i++;
                            continue;
                        }
                        
                        // Look ahead to see if next non-empty lines have Artist/Album/Price bullets
                        let j = i + 1;
                        while (j < lines.length && lines[j].trim() === '') j++;
                        
                        // Check if we have invoice item bullets following
                        const details = {};
                        let foundInvoiceDetails = false;
                        let bulletEndIdx = j;
                        
                        while (j < lines.length) {
                            const bulletLine = lines[j];
                            if (bulletLine.trim() === '') {
                                j++;
                                continue;
                            }
                            
                            // Check for bullet with key-value
                            const bulletMatch = bulletLine.match(/^\s*[-•]\s*\*?\*?([^:*]+)\*?\*?\s*:\s*(.+?)\s*$/);
                            if (!bulletMatch) break;
                            
                            const key = bulletMatch[1].trim().toLowerCase().replace(/\s+/g, '');
                            const value = cleanBold(bulletMatch[2]);
                            
                            if (key === 'artist' || key === 'artistname') {
                                details.artist = value;
                                foundInvoiceDetails = true;
                            } else if (key === 'album' || key === 'albumtitle') {
                                details.album = value;
                                foundInvoiceDetails = true;
                            } else if (key === 'unitprice' || key === 'price') {
                                details.unitPrice = normalizePrice(value);
                                foundInvoiceDetails = true;
                            } else if (key === 'quantity' || key === 'qty') {
                                details.quantity = value;
                                foundInvoiceDetails = true;
                            } else {
                                // Not an invoice item bullet
                                break;
                            }
                            
                            bulletEndIdx = j + 1;
                            j++;
                        }
                        
                        // If we found invoice item details, treat the current line as track name
                        if (foundInvoiceDetails && (details.artist || details.unitPrice)) {
                            // Extract track name - remove any leading numbering, "even", etc.
                            let trackName = line.trim();
                            // Remove numbered prefix like "1. " or "- "
                            trackName = trackName.replace(/^(?:\d+\.\s*)?(?:[-•]\s*)?/, '');
                            // Clean bold markers
                            trackName = cleanBold(trackName);
                            
                            rows.push({
                                trackName,
                                artist: details.artist || '',
                                album: details.album || '',
                                unitPrice: details.unitPrice || '',
                                quantity: details.quantity || '1'
                            });
                            i = bulletEndIdx;
                        } else {
                            kept.push(line);
                            i++;
                        }
                    }

                    if (rows.length > 0) {
                        return { tableData: rows, tableType: 'invoice-items', remaining: kept.join('\n').trim() };
                    }
                    return null;
                }
                
                // Strategy 4b: Inline format
                // Format: "- **Track Name:** Song - **Artist:** Artist - **Album:** Album - **Unit Price:** $0.99"
                function detectInlineInvoiceItems() {
                    const pattern = /[-•]\s*\*\*Track(?:\s*Name)?:\*\*\s*([^*\n-]+?)(?:\s*[-–]\s*\*\*Artist:\*\*\s*([^*\n-]+?))?(?:\s*[-–]\s*\*\*Album:\*\*\s*([^*\n-]+?))?(?:\s*[-–]\s*\*\*(?:Unit\s*)?Price:\*\*\s*\$?([\d.]+))?(?:\s*[-–]\s*\*\*Quantity:\*\*\s*(\d+))?/gi;
                    
                    const matches = Array.from(raw.matchAll(pattern));
                    if (matches.length >= 1) {
                        let remaining = raw;
                        const rows = matches.map(m => {
                            remaining = remaining.replace(m[0], '');
                            return {
                                trackName: cleanBold(m[1]),
                                artist: cleanBold(m[2] || ''),
                                album: cleanBold(m[3] || ''),
                                unitPrice: normalizePrice(m[4]),
                                quantity: m[5] || '1'
                            };
                        });
                        return { tableData: rows, tableType: 'invoice-items', remaining: remaining.trim() };
                    }
                    return null;
                }
                
                // Try block format first (more specific)
                const blockResult = detectInvoiceItemBlocks();
                if (blockResult) return blockResult;
                
                // Fall back to inline format
                return detectInlineInvoiceItems();
            }

            // Strategy 5: Purchase confirmation
            // Format: "- Invoice ID: 123 - Track: Song - Amount: $0.99 - Date: ..."
            function detectPurchaseConfirmation() {
                const pattern = /[-•]\s*Invoice\s*ID:\s*(\d+)\s*[-–]\s*Track:\s*([^-\n]+?)\s*[-–]\s*Amount:\s*\$?([\d.]+)\s*[-–]\s*Date:\s*([^\n]+)/gi;
                
                const matches = Array.from(raw.matchAll(pattern));
                if (matches.length >= 1) {
                    let remaining = raw;
                    const rows = matches.map(m => {
                        remaining = remaining.replace(m[0], '');
                        return {
                            invoiceId: m[1],
                            track: cleanBold(m[2]),
                            amount: normalizePrice(m[3]),
                            date: m[4].trim()
                        };
                    });
                    return { tableData: rows, tableType: 'purchase-confirmation', remaining: remaining.trim() };
                }
                return null;
            }

            // Strategy 6: Profile / Account info (key-value pairs)
            // Format: "- **Name:** John Doe" or "**Email:** john@example.com"
            function detectProfile() {
                const pattern = /[-•]?\s*\*\*([^:*]+?):\*\*\s*([^\n*]+)/gi;
                const matches = Array.from(raw.matchAll(pattern));
                
                // Only treat as profile if we have common profile fields
                const profileFields = ['name', 'email', 'phone', 'address', 'city', 'state', 'country', 'postal', 'zip', 'customer'];
                // Exclude invoice-related fields from profile detection
                const excludeFields = ['invoice', 'billing', 'date', 'total', 'track', 'price', 'amount', 'quantity'];
                
                const relevantMatches = matches.filter(m => {
                    const label = m[1].toLowerCase();
                    // Must match a profile field and NOT match an exclude field
                    const isProfile = profileFields.some(f => label.includes(f));
                    const isExcluded = excludeFields.some(f => label.includes(f));
                    return isProfile && !isExcluded;
                });

                if (relevantMatches.length >= 2) {
                    let remaining = raw;
                    const rows = relevantMatches.map(m => {
                        remaining = remaining.replace(m[0], '');
                        return {
                            label: cleanBold(m[1]),
                            value: cleanBold(m[2])
                        };
                    });
                    return { tableData: rows, tableType: 'profile', remaining: remaining.trim() };
                }
                return null;
            }

            // Strategy 7: Simple numbered list with bold items (albums, artists)
            // Format: "1. **Album Name**" or "1. **Artist Name**"
            function detectBoldNumberedList() {
                const pattern = /^(\d+)\.\s+\*\*([^*]+)\*\*\s*$/gm;
                const matches = Array.from(raw.matchAll(pattern));
                
                // Require at least 2 items and no complex data
                if (matches.length >= 2) {
                    const hasComplexData = matches.some(m => 
                        /TrackId|Price|Invoice|Date:/i.test(m[0])
                    );
                    
                    if (!hasComplexData) {
                        let remaining = raw;
                        const rows = matches.map(m => {
                            remaining = remaining.replace(m[0], '');
                            return {
                                number: m[1],
                                name: cleanBold(m[2])
                            };
                        });
                        
                        // Infer type from context
                        const beforeList = raw.slice(0, matches[0].index).toLowerCase();
                        let tableType = 'items';
                        if (/albums?\b/.test(beforeList)) tableType = 'albums';
                        else if (/artists?\b/.test(beforeList)) tableType = 'artists';
                        else if (/tracks?\b|songs?\b/.test(beforeList)) tableType = 'tracks-simple';
                        else if (/genres?\b/.test(beforeList)) tableType = 'genres';
                        
                        return { tableData: rows, tableType, remaining: remaining.trim() };
                    }
                }
                return null;
            }

            // Strategy 8: Plain numbered list (genres, simple names)
            // Format: "1. Rock" or "1. AC/DC"
            function detectPlainNumberedList() {
                const pattern = /^(\d+)\.\s+([^*\n]+)$/gm;
                const matches = Array.from(raw.matchAll(pattern));
                
                if (matches.length >= 2) {
                    // Skip if contains structured data markers
                    const hasStructured = matches.some(m => 
                        /\*\*|TrackId|Price|Invoice|Date:|[-–].*:/.test(m[2])
                    );
                    
                    if (!hasStructured) {
                        let remaining = raw;
                        const rows = matches.map(m => {
                            remaining = remaining.replace(m[0], '');
                            return {
                                number: m[1],
                                name: m[2].trim()
                            };
                        });
                        
                        // Infer type from context
                        const beforeList = raw.slice(0, matches[0].index).toLowerCase();
                        let tableType = 'items';
                        if (/genres?\b/.test(beforeList)) tableType = 'genres';
                        else if (/artists?\b/.test(beforeList)) tableType = 'artists';
                        else if (/albums?\b/.test(beforeList)) tableType = 'albums';
                        else if (/tracks?\b|songs?\b/.test(beforeList)) tableType = 'tracks-simple';
                        
                        return { tableData: rows, tableType, remaining: remaining.trim() };
                    }
                }
                return null;
            }

            // Strategy 9: Simple bullet list (dash-prefixed items without structured data)
            // Format: "- Rock" or "- Alternative & Punk"
            function detectSimpleBulletList() {
                const pattern = /^[-•]\s+([^*\n:]+)$/gm;
                const matches = Array.from(raw.matchAll(pattern));
                
                if (matches.length >= 3) {
                    // Skip if contains structured data markers (key: value patterns)
                    const hasStructured = matches.some(m => 
                        /\*\*|TrackId|Price|Invoice|Date/i.test(m[1])
                    );
                    
                    if (!hasStructured) {
                        let remaining = raw;
                        const rows = matches.map((m, idx) => {
                            remaining = remaining.replace(m[0], '');
                            return {
                                number: String(idx + 1),
                                name: m[1].trim()
                            };
                        });
                        
                        // Infer type from context before the list
                        const beforeList = raw.slice(0, matches[0].index).toLowerCase();
                        let tableType = 'items';
                        if (/genres?\b/.test(beforeList)) tableType = 'genres';
                        else if (/artists?\b/.test(beforeList)) tableType = 'artists';
                        else if (/albums?\b/.test(beforeList)) tableType = 'albums';
                        else if (/tracks?\b|songs?\b/.test(beforeList)) tableType = 'tracks-simple';
                        
                        return { tableData: rows, tableType, remaining: remaining.trim() };
                    }
                }
                return null;
            }

            // Strategy 9: Raw data format (JSON-like or Python dict format)
            // Handles cases where tool output is shown more directly
            function detectRawDataFormat() {
                // Look for patterns like [{'InvoiceId': 382, 'InvoiceDate': '2025-08-07'...}]
                // or {"InvoiceId": 382, "InvoiceDate": "2025-08-07"...}
                
                // Invoice data pattern
                const invoiceDataPattern = /\[\s*\{[^}]*['"]InvoiceId['"]:\s*(\d+)[^}]*['"]InvoiceDate['"]:\s*['"]([^'"]+)['"][^}]*['"]Total['"]:\s*([\d.]+)[^}]*\}/gi;
                const invoiceMatches = Array.from(raw.matchAll(invoiceDataPattern));
                
                if (invoiceMatches.length >= 1) {
                    // This is raw invoice data - try to extract all records
                    const recordPattern = /\{[^}]*['"]InvoiceId['"]:\s*(\d+)[^}]*['"]InvoiceDate['"]:\s*['"]([^'"]+)['"][^}]*['"]Total['"]:\s*([\d.]+)[^}]*\}/gi;
                    const allMatches = Array.from(raw.matchAll(recordPattern));
                    
                    if (allMatches.length >= 1) {
                        let remaining = raw;
                        const rows = allMatches.map((m, idx) => {
                            remaining = remaining.replace(m[0], '');
                            return {
                                number: String(idx + 1),
                                invoiceId: m[1],
                                date: m[2].replace(/\s+\d{2}:\d{2}:\d{2}/, ''),
                                total: normalizePrice(m[3])
                            };
                        });
                        // Clean up remaining brackets and commas
                        remaining = remaining.replace(/^\s*\[\s*,?\s*/, '').replace(/\s*,?\s*\]\s*$/, '').trim();
                        return { tableData: rows, tableType: 'invoices', remaining };
                    }
                }

                // Track data pattern  
                const trackDataPattern = /\[\s*\{[^}]*['"]TrackId['"]:\s*(\d+)[^}]*['"](?:TrackName|Name)['"]:\s*['"]([^'"]+)['"][^}]*\}/gi;
                const trackMatches = Array.from(raw.matchAll(trackDataPattern));
                
                if (trackMatches.length >= 1) {
                    const recordPattern = /\{[^}]*['"]TrackId['"]:\s*(\d+)[^}]*['"](?:TrackName|Name)['"]:\s*['"]([^'"]+)['"][^}]*(?:['"]UnitPrice['"]:\s*([\d.]+))?[^}]*\}/gi;
                    const allMatches = Array.from(raw.matchAll(recordPattern));
                    
                    if (allMatches.length >= 1) {
                        let remaining = raw;
                        const rows = allMatches.map((m, idx) => {
                            remaining = remaining.replace(m[0], '');
                            return {
                                number: String(idx + 1),
                                trackId: m[1],
                                name: m[2],
                                price: m[3] ? normalizePrice(m[3]) : ''
                            };
                        });
                        remaining = remaining.replace(/^\s*\[\s*,?\s*/, '').replace(/\s*,?\s*\]\s*$/, '').trim();
                        return { tableData: rows, tableType: 'tracks', remaining };
                    }
                }

                return null;
            }

            // Execute strategies in order of specificity
            const strategies = [
                detectTrackBlocks,
                detectInlineTracks,
                detectPurchaseHistory,
                detectInvoiceLineItems,
                detectPurchaseConfirmation,
                detectRawDataFormat,  // Added to catch raw tool output
                detectProfile,
                detectBoldNumberedList,
                detectPlainNumberedList,
                detectSimpleBulletList,  // Simple dash-prefixed lists (genres, etc.)
            ];

            for (const strategy of strategies) {
                const result = strategy();
                if (result) {
                    // Clean up remaining text
                    let remaining = result.remaining
                        .replace(/\*\*Album:[^*\n]+\*\*/g, '') // Remove album headers
                        .replace(/\n{3,}/g, '\n\n') // Collapse multiple newlines
                        .trim();
                    return { ...result, remaining };
                }
            }

            return { tableData: null, tableType: null, remaining: raw };
        }

        /**
         * Creates a beautifully styled table from parsed data
         * Handles all table types with consistent styling and proper column names
         */
        function createTable(tableData, tableType) {
            if (!tableData || tableData.length === 0) return null;

            const table = document.createElement('table');
            table.className = 'message-table';
            
            const thead = document.createElement('thead');
            const tbody = document.createElement('tbody');
            const headerRow = document.createElement('tr');

            // Configuration for each table type
            const tableConfigs = {
                'tracks': {
                    getColumns: (data) => {
                        const cols = [
                            { key: 'number', header: '#', class: 'table-number' },
                            { key: 'name', header: 'Track', class: '', bold: true },
                        ];
                        if (data.some(r => r.trackId)) cols.push({ key: 'trackId', header: 'ID', class: 'table-id' });
                        if (data.some(r => r.artist)) cols.push({ key: 'artist', header: 'Artist', class: '' });
                        if (data.some(r => r.album)) cols.push({ key: 'album', header: 'Album', class: '' });
                        if (data.some(r => r.duration)) cols.push({ key: 'duration', header: 'Duration', class: 'table-duration' });
                        if (data.some(r => r.genre)) cols.push({ key: 'genre', header: 'Genre', class: '' });
                        if (data.some(r => r.price)) cols.push({ key: 'price', header: 'Price', class: 'table-price' });
                        return cols;
                    }
                },
                'tracks-simple': {
                    columns: [
                        { key: 'number', header: '#', class: 'table-number' },
                        { key: 'name', header: 'Track', class: '', bold: true }
                    ]
                },
                'invoices': {
                    getColumns: (data) => {
                        const cols = [
                            { key: 'number', header: '#', class: 'table-number' },
                            { key: 'invoiceId', header: 'Invoice', class: 'table-id' },
                            { key: 'date', header: 'Date', class: 'table-date' },
                        ];
                        if (data.some(r => r.city)) cols.push({ key: 'city', header: 'City', class: '' });
                        if (data.some(r => r.country)) cols.push({ key: 'country', header: 'Country', class: '' });
                        cols.push({ key: 'total', header: 'Total', class: 'table-price' });
                        return cols;
                    }
                },
                'invoice-items': {
                    getColumns: (data) => {
                        const cols = [
                            { key: 'trackName', header: 'Track', class: '', bold: true },
                        ];
                        if (data.some(r => r.artist)) cols.push({ key: 'artist', header: 'Artist', class: '' });
                        if (data.some(r => r.album)) cols.push({ key: 'album', header: 'Album', class: '' });
                        cols.push({ key: 'unitPrice', header: 'Price', class: 'table-price' });
                        cols.push({ key: 'quantity', header: 'Qty', class: 'table-number' });
                        return cols;
                    }
                },
                'purchase-confirmation': {
                    columns: [
                        { key: 'invoiceId', header: 'Invoice ID', class: 'table-id' },
                        { key: 'track', header: 'Track', class: '', bold: true },
                        { key: 'amount', header: 'Amount', class: 'table-price' },
                        { key: 'date', header: 'Date', class: 'table-date' }
                    ]
                },
                'profile': {
                    columns: [
                        { key: 'label', header: 'Field', class: 'table-label', bold: true },
                        { key: 'value', header: 'Value', class: '' }
                    ]
                },
                'albums': {
                    columns: [
                        { key: 'number', header: '#', class: 'table-number' },
                        { key: 'name', header: 'Album', class: '', bold: true }
                    ]
                },
                'artists': {
                    columns: [
                        { key: 'number', header: '#', class: 'table-number' },
                        { key: 'name', header: 'Artist', class: '', bold: true }
                    ]
                },
                'genres': {
                    columns: [
                        { key: 'number', header: '#', class: 'table-number' },
                        { key: 'name', header: 'Genre', class: '', bold: true }
                    ]
                },
                'items': {
                    columns: [
                        { key: 'number', header: '#', class: 'table-number' },
                        { key: 'name', header: 'Name', class: '', bold: true }
                    ]
                }
            };

            // Get configuration for this table type
            const config = tableConfigs[tableType] || tableConfigs['items'];
            const columns = config.getColumns ? config.getColumns(tableData) : config.columns;

            // Build header
            columns.forEach(col => {
                const th = document.createElement('th');
                th.textContent = col.header;
                headerRow.appendChild(th);
            });

            // Build rows
            tableData.forEach(row => {
                const tr = document.createElement('tr');
                columns.forEach(col => {
                    const td = document.createElement('td');
                    if (col.class) td.className = col.class;
                    
                    const value = escapeHtml(String(row[col.key] ?? ''));
                    if (col.bold && value) {
                        td.innerHTML = `<strong>${value}</strong>`;
                    } else if (col.class === 'table-id' && value) {
                        // Wrap ID values in a span for badge styling
                        td.innerHTML = `<span class="id-badge">${value}</span>`;
                    } else {
                        td.textContent = value;
                    }
                    tr.appendChild(td);
                });
                tbody.appendChild(tr);
            });

            thead.appendChild(headerRow);
            table.appendChild(thead);
            table.appendChild(tbody);
            
            return table;
        }

        function renderMessageBubble(bubbleEl, role, content) {
            // Always render via DOM APIs (no HTML injection)
            bubbleEl.textContent = '';

            if (role !== 'assistant') {
                bubbleEl.textContent = content ?? '';
                return;
            }

            const raw = String(content ?? '');

            // Minimal media detection: first YouTube URL (plain or markdown) OR first .mp4 URL
            const ytMarkdownRegex = /\[([^\]]+)\]\((https?:\/\/(?:www\.)?(?:youtube\.com\/watch\?v=|youtube\.com\/embed\/|youtu\.be\/)([a-zA-Z0-9_-]{11})[^\)]*)\)/i;
            const ytRegex = /https?:\/\/(?:www\.)?(?:youtube\.com\/embed\/|youtube\.com\/watch\?v=|youtu\.be\/)([a-zA-Z0-9_-]{11})(?:[^\s]*)?/i;
            const mp4Regex = /https?:\/\/[^\s]+?\.mp4(?:\?[^\s]*)?/i;

            const ytMdMatch = raw.match(ytMarkdownRegex);
            const ytMatch = ytMdMatch ? null : raw.match(ytRegex);
            const mp4Match = raw.match(mp4Regex);

            const hasVideo = ytMdMatch || ytMatch || mp4Match;
            let remaining = raw;

            if (hasVideo) {
                // Create structured video message layout
                const wrapper = document.createElement('div');
                wrapper.className = 'video-message-wrapper';

                // Clean and parse the text
                let textContent = remaining
                    .replace(/\r\n/g, '\n')
                    .replace(/\[Watch on YouTube\]\s*/gi, '')
                    .replace(/^\s*youtube:\s*$/gmi, '')
                    .replace(/on YouTube:\s*\n*/gi, '')
                    .replace(/YouTube:\s*\n*/gi, '');

                // Remove the video URL from text
                if (ytMdMatch) textContent = textContent.replace(ytMdMatch[0], '');
                else if (ytMatch) textContent = textContent.replace(ytMatch[0], '');
                else if (mp4Match) textContent = textContent.replace(mp4Match[0], '');

                textContent = textContent.replace(/\n{2,}/g, '\n').trim();

                // Split into header and footer based on common patterns
                // Header: Everything before "Here's a video" or similar, or first sentence with track info
                // Footer: Status info (available/not available) and CTA questions
                let headerText = '';
                let footerText = '';

                // Pattern to find the "intro" part (track identification)
                const introMatch = textContent.match(/^(.*?(?:by\s+\*\*[^*]+\*\*[!.]?))/i);
                if (introMatch) {
                    headerText = introMatch[1].trim();
                    footerText = textContent.slice(introMatch[0].length).trim();
                } else {
                    // Fallback: split at "Here's a video" or first question
                    const splitMatch = textContent.match(/^(.*?)(?:Here'?s a video|Unfortunately|This track|Would you|Is this)/i);
                    if (splitMatch && splitMatch[1]) {
                        headerText = splitMatch[1].trim();
                        footerText = textContent.slice(splitMatch[1].length).trim();
                    } else {
                        headerText = textContent;
                    }
                }

                // Clean up footer - remove "Here's a video so you can take a listen:" type phrases
                footerText = footerText
                    .replace(/^Here'?s a video[^:]*:?\s*/i, '')
                    .replace(/^so you can (?:take a )?listen[.:]\s*/i, '')
                    .trim();

                // Create header element
                if (headerText) {
                    const header = document.createElement('div');
                    header.className = 'video-message-header';
                    
                    // Convert markdown bold and add music icon
                    let headerHtml = headerText
                        .replace(/🎵\s*/g, '')  // Remove emoji, we'll add icon
                        .replace(/\*\*\s+/g, '**')  // Remove space after opening **
                        .replace(/\s+\*\*/g, '**')  // Remove space before closing **
                        .replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>')
                        .replace(/<\/strong>\s+([!?.,])/g, '</strong>$1')  // Remove space between </strong> and punctuation
                        .replace(/\s+([!?.,])/g, '$1')  // Remove extra space before punctuation
                        .replace(/\s{2,}/g, ' ')  // Collapse multiple spaces
                        .trim();
                    
                    header.innerHTML = `<div class="track-info"><span class="music-icon">${icons.music}</span> ${headerHtml}</div>`;
                    wrapper.appendChild(header);
                }

                // Add video
                if (ytMdMatch) {
                    wrapper.appendChild(createYouTubeThumbnailCard(ytMdMatch[3], ytMdMatch[2]));
                } else if (ytMatch) {
                    wrapper.appendChild(createYouTubeThumbnailCard(ytMatch[1], ytMatch[0]));
                } else if (mp4Match) {
                    wrapper.appendChild(createMp4Embed(mp4Match[0]));
                }

                // Create footer element with status and CTA
                if (footerText) {
                    const footer = document.createElement('div');
                    footer.className = 'video-message-footer';

                    // Parse footer into status and CTA lines
                    const lines = footerText.split(/\n/).filter(l => l.trim());
                    
                    lines.forEach(line => {
                        line = line.trim();
                        if (!line) return;

                        const lineEl = document.createElement('div');
                        
                        // Detect line type
                        const isAvailable = /available.*\$|for\s+\*?\*?\$[\d.]+/i.test(line);
                        const isUnavailable = /not.*(?:available|catalogue|catalog)|isn't.*(?:available|catalogue|catalog)|Unfortunately/i.test(line);
                        const isCTA = /\?$|would you|is this|let me know/i.test(line);

                        // Convert markdown
                        let lineHtml = line.replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>');

                        // Style price tags
                        lineHtml = lineHtml.replace(/\$(\d+\.?\d*)/g, '<span class="price-tag">$$$1</span>');

                        if (isCTA) {
                            lineEl.className = 'cta-line';
                            lineEl.innerHTML = lineHtml;
                        } else if (isAvailable) {
                            lineEl.className = 'status-line available';
                            lineEl.innerHTML = `<span class="status-icon">${icons.checkCircle}</span> ${lineHtml}`;
                        } else if (isUnavailable) {
                            lineEl.className = 'status-line unavailable';
                            lineEl.innerHTML = `<span class="status-icon">${icons.info}</span> ${lineHtml}`;
                        } else {
                            lineEl.className = 'status-line';
                            lineEl.innerHTML = lineHtml;
                        }

                        footer.appendChild(lineEl);
                    });

                    if (footer.children.length > 0) {
                        wrapper.appendChild(footer);
                    }
                }

                bubbleEl.appendChild(wrapper);
                // Add class to message-content for CSS targeting (more reliable than :has())
                const messageContent = bubbleEl.closest('.message-content');
                if (messageContent) {
                    messageContent.classList.add('has-video');
                }
                remaining = '';  // All content handled
            }

            // Check for ordered lists that should be converted to tables
            if (remaining) {
                const { tableData, tableType, remaining: textAfterTable } = parseListToTable(remaining);
                
                if (tableData && tableData.length > 0) {
                    const table = createTable(tableData, tableType);
                    if (table) {
                        bubbleEl.appendChild(table);
                        remaining = textAfterTable;
                    }
                }
            }

            if (remaining) {
                const textEl = document.createElement('div');
                textEl.className = 'message-text';
                let cleaned = remaining
                    .replace(/\r\n/g, '\n')
                    .replace(/\n{2,}/g, '\n')
                    .trim();
                
                // Convert markdown bold to HTML
                cleaned = cleaned.replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>');
                
                // Convert newlines to proper line breaks for multi-line text
                cleaned = cleaned.replace(/\n/g, '<br>');
                
                // Replace emojis with Lucide icons for design consistency
                cleaned = cleaned
                    .replace(/🎵/g, `<span class="inline-icon">${icons.music}</span>`)
                    .replace(/📱/g, `<span class="inline-icon">${icons.smartphone}</span>`)
                    .replace(/✅/g, `<span class="inline-icon">${icons.checkCircle}</span>`)
                    .replace(/❌/g, `<span class="inline-icon">${icons.xCircle}</span>`);
                
                textEl.innerHTML = cleaned;
                bubbleEl.appendChild(textEl);
            }
        }

        function createYouTubeThumbnailCard(videoId, watchUrl) {
            const wrap = document.createElement('div');
            wrap.className = 'video-card';

            const a = document.createElement('a');
            a.href = watchUrl || `https://www.youtube.com/watch?v=${videoId}`;
            a.target = '_blank';
            a.rel = 'noopener noreferrer';
            a.ariaLabel = 'Open YouTube video in a new tab';

            const img = document.createElement('img');
            img.alt = 'YouTube video thumbnail';
            img.loading = 'lazy';
            img.referrerPolicy = 'no-referrer';
            img.src = `https://i.ytimg.com/vi/${videoId}/hqdefault.jpg`;
            img.onerror = function () {
                this.onerror = null;
                this.src = `https://i.ytimg.com/vi/${videoId}/mqdefault.jpg`;
            };

            const play = document.createElement('div');
            play.className = 'video-card-play';
            play.innerHTML = '<span><svg viewBox="0 0 24 24" aria-hidden="true"><path d="M8 5v14l11-7z"></path></svg></span>';

            a.appendChild(img);
            wrap.appendChild(a);
            wrap.appendChild(play);
            return wrap;
        }

        function createMp4Embed(url) {
            const wrap = document.createElement('div');
            wrap.className = 'video-embed';

            const video = document.createElement('video');
            video.src = url;
            video.controls = true;
            video.preload = 'metadata';
            wrap.appendChild(video);

            return wrap;
        }

        function formatNodeName(name) {
            return name.replace(/_/g, ' ').replace(/\b\w/g, c => c.toUpperCase());
        }
    </script>
</body>
</html>

