"""Lyrics identification subgraph.

A self-contained workflow for identifying songs from lyrics.
Following "Thinking in LangGraph" - each step is its own node.

IMPORTANT: This subgraph uses separate Input/Output schemas to prevent message
accumulation. The parent graph passes context via specific fields, NOT the full
message history. This prevents duplicate messages when the subgraph returns.

Flow:
    START â†’ identify_song â†’ check_catalog â†’ get_youtube â†’ present_options (HITL) â†’ END
    
Uses interrupt() for purchase/request decisions, consistent with purchase and 
email_change subgraphs. This provides clear UX and prevents the awkward 
"conversational but not really" pattern.
"""

from typing import Annotated, Optional, Literal

from langchain_core.messages import AIMessage, BaseMessage, HumanMessage, SystemMessage
from langchain_openai import ChatOpenAI
from langgraph.graph import StateGraph, START, END
from langgraph.graph.message import add_messages
from langgraph.types import Command, interrupt
from typing_extensions import TypedDict
from pydantic import BaseModel, Field

from src.tools.mocks import genius_search, youtube_lookup, check_song_in_catalog
from src.tools.account import check_if_already_purchased


class ExtractedLyrics(BaseModel):
    """Extracted lyrics from user message."""
    
    lyrics: str = Field(
        description="The actual song lyrics/words the user is trying to identify. Extract ONLY the lyrics themselves, not the surrounding question."
    )
    
    has_lyrics: bool = Field(
        description="True if the user provided actual lyrics to search for, False if they just asked about lyrics in general without providing any."
    )


# =============================================================================
# SCHEMA DEFINITIONS - Separate Input/Output to prevent message accumulation
# =============================================================================

class LyricsInputSchema(TypedDict):
    """What the subgraph receives from parent.
    
    NOTE: We do NOT include the full messages list here. Instead, we receive
    the user's current message via `current_user_message`. This prevents the
    parent's message history from flowing into the subgraph and being re-emitted.
    """
    customer_id: int
    
    # The current user message (passed by catalog_qa)
    current_user_message: Optional[str]
    
    # Lyrics query (the original lyrics text)
    lyrics_query: Optional[str]


class LyricsOutputSchema(TypedDict):
    """What the subgraph returns to parent.
    
    Only includes NEW messages generated by this subgraph run, plus state
    updates. The parent's add_messages reducer will append these new messages.
    """
    # Only NEW messages from this subgraph run
    messages: Annotated[list[BaseMessage], add_messages]
    
    # Purchase handoff - set if user confirms purchase (cleared on decline)
    lyrics_purchase_confirmed: Optional[bool]
    pending_track_id: Optional[int]
    pending_track_name: Optional[str]
    pending_track_price: Optional[float]
    
    # Last identified track - ALWAYS set when track found, NOT cleared on decline
    # Used for "the song from before" type references
    last_identified_track_id: Optional[int]
    last_identified_track_name: Optional[str]
    last_identified_track_artist: Optional[str]


class LyricsInternalState(TypedDict):
    """Internal working state for the subgraph.
    
    This is the full state used during subgraph execution. It includes
    everything from input plus internal working fields.
    """
    # From input
    customer_id: int
    current_user_message: Optional[str]
    lyrics_query: Optional[str]
    
    # Internal working state (not in input/output)
    identified_song: Optional[str]
    identified_artist: Optional[str]
    song_in_catalog: Optional[bool]
    track_id: Optional[int]
    track_price: Optional[float]
    already_owned: Optional[bool]
    youtube_url: Optional[str]
    
    # Output - messages generated by this run
    messages: Annotated[list[BaseMessage], add_messages]
    
    # Output flags
    lyrics_purchase_confirmed: Optional[bool]
    pending_track_id: Optional[int]
    pending_track_name: Optional[str]
    pending_track_price: Optional[float]
    
    # Persistent track memory (not cleared on decline)
    last_identified_track_id: Optional[int]
    last_identified_track_name: Optional[str]
    last_identified_track_artist: Optional[str]


# =============================================================================
# HELPER FUNCTIONS
# =============================================================================

def _get_user_message(state: LyricsInternalState) -> str:
    """Get the current user message from state.
    
    Uses current_user_message field (passed from parent) instead of
    searching through messages list.
    """
    return state.get("current_user_message", "").strip()


def _extract_lyrics_from_message(user_message: str, lyrics_query: Optional[str]) -> str:
    """Extract just the lyrics from the user's message using LLM.
    
    Users often wrap lyrics in context like:
    - "what song goes like [lyrics]"
    - "I heard this song, it went like [lyrics]"
    - "here are the lyrics: [lyrics]"
    - "do you know the song that goes [lyrics]"
    
    We use an LLM to extract just the lyrics portion for cleaner Genius search.
    """
    if not user_message or len(user_message) < 5:
        return lyrics_query or ""
    
    # Use LLM to extract just the lyrics
    model = ChatOpenAI(model="gpt-4o-mini", temperature=0)
    extractor = model.with_structured_output(ExtractedLyrics)
    
    result = extractor.invoke([
        SystemMessage(content="""Extract the actual song lyrics from the user's message.

Users ask about songs in many ways:
- "what song goes like [lyrics]" â†’ extract just the lyrics
- "I heard this song it went like [lyrics]" â†’ extract just the lyrics  
- "here are the lyrics: [lyrics]" â†’ extract just the lyrics
- "do you know [lyrics]" â†’ extract just the lyrics
- "[just lyrics directly]" â†’ extract the lyrics

Extract ONLY the lyrics/words they're trying to identify, NOT the question framing.

Examples:
- Input: "what song goes I got my mind set on you" â†’ lyrics: "I got my mind set on you"
- Input: "do you know the song that goes we will rock you" â†’ lyrics: "we will rock you"
- Input: "I heard a song today, the chorus went something like 'don't stop believing'" â†’ lyrics: "don't stop believing"
- Input: "is this the real life is this just fantasy" â†’ lyrics: "is this the real life is this just fantasy"

If the user is asking about lyrics in general without providing any actual lyrics, set has_lyrics to False."""),
        HumanMessage(content=user_message)
    ])
    
    if result.has_lyrics and result.lyrics:
        return result.lyrics.strip()
    
    # Fallback to the whole message if extraction failed
    return user_message


# =============================================================================
# NODE FUNCTIONS
# =============================================================================

def identify_song_node(state: LyricsInternalState) -> Command[Literal["check_catalog", "__end__"]]:
    """Step 1: Identify the song from lyrics using Genius API."""
    user_message = _get_user_message(state)
    lyrics_query = state.get("lyrics_query")
    lyrics = _extract_lyrics_from_message(user_message, lyrics_query)
    
    if not lyrics:
        return Command(
            update={
                "messages": [AIMessage(content="I'd be happy to help identify a song! Could you share some lyrics?")],
                "identified_song": None,
                "lyrics_purchase_confirmed": False,
            },
            goto="__end__"
        )
    
    # Call Genius to identify the song
    result = genius_search.invoke({"lyrics_snippet": lyrics})
    
    # Parse the result to extract song info
    if "Could not identify" in result:
        return Command(
            update={
                "messages": [AIMessage(content="I couldn't identify a song from those lyrics. Could you try providing more of the lyrics or the song title directly?")],
                "identified_song": None,
                "lyrics_purchase_confirmed": False,
            },
            goto="__end__"
        )
    
    # Extract song and artist from result
    song_title = None
    artist = None
    
    for line in result.split("\n"):
        if "Title:" in line:
            song_title = line.split("Title:")[-1].strip()
        elif "Artist:" in line:
            artist = line.split("Artist:")[-1].strip()
    
    if not song_title:
        return Command(
            update={
                "messages": [AIMessage(content="I had trouble parsing the song identification. Could you try again?")],
                "lyrics_purchase_confirmed": False,
            },
            goto="__end__"
        )
    
    return Command(
        update={
            "identified_song": song_title,
            "identified_artist": artist or "Unknown Artist",
        },
        goto="check_catalog"
    )


def check_catalog_node(state: LyricsInternalState) -> Command[Literal["get_youtube"]]:
    """Step 2: Check if the song is in our catalog."""
    song_title = state.get("identified_song", "")
    artist = state.get("identified_artist", "")
    customer_id = state.get("customer_id", 1)
    
    # Check if song is in catalog
    result = check_song_in_catalog.invoke({
        "song_title": song_title,
        "artist": artist
    })
    
    in_catalog = "Found in catalog" in result
    track_id = None
    track_price = 0.99
    already_owned = False
    
    if in_catalog:
        # Parse track ID and price
        import re
        track_id_match = re.search(r"TrackId:\s*(\d+)", result)
        price_match = re.search(r"Price:\s*\$?([\d.]+)", result)
        
        if track_id_match:
            track_id = int(track_id_match.group(1))
        if price_match:
            track_price = float(price_match.group(1))
        
        # Check if already owned
        if track_id:
            config = {"configurable": {"customer_id": customer_id}}
            ownership_result = check_if_already_purchased.invoke(
                {"track_id": track_id}, 
                config=config
            )
            already_owned = "Yes" in ownership_result
    
    return Command(
        update={
            "song_in_catalog": in_catalog,
            "track_id": track_id,
            "track_price": track_price,
            "already_owned": already_owned,
        },
        goto="get_youtube"
    )


def get_youtube_node(state: LyricsInternalState) -> Command[Literal["present_options"]]:
    """Step 3: Get a YouTube video link."""
    song_title = state.get("identified_song", "")
    artist = state.get("identified_artist", "")
    
    # Get YouTube link
    result = youtube_lookup.invoke({
        "song_title": song_title,
        "artist": artist
    })
    
    # Extract URL from result
    youtube_url = result.strip() if result else None
    
    return Command(
        update={
            "youtube_url": youtube_url,
        },
        goto="present_options"
    )


def present_options_node(state: LyricsInternalState) -> dict:
    """Step 4: Present the info and ask the user using HITL interrupt.
    
    Uses interrupt() for clear decision point, consistent with other subgraphs.
    The interrupt type is "choice" for inline button rendering in the UI.
    The full song info is included in the interrupt message so users see everything.
    """
    song_title = state.get("identified_song", "Unknown")
    artist = state.get("identified_artist", "Unknown Artist")
    in_catalog = state.get("song_in_catalog", False)
    track_price = state.get("track_price", 0.99)
    already_owned = state.get("already_owned", False)
    youtube_url = state.get("youtube_url", "")
    track_id = state.get("track_id")
    
    # Build info message
    info_msg = f"ðŸŽµ I found it! That's **{song_title}** by **{artist}**!"
    if youtube_url:
        info_msg += f"\n\nHere's a video so you can take a listen:\n{youtube_url}"
    
    # Case 1: Already owned - no decision needed
    if already_owned:
        info_msg += "\n\nâœ… Great news! You already own this track - it's in your library!"
        info_msg += "\n\nIs there anything else I can help you with?"
        
        return {
            "messages": [AIMessage(content=info_msg)],
            "lyrics_purchase_confirmed": False,
            "pending_track_id": None,
            "pending_track_name": None,
            "pending_track_price": None,
            # ALWAYS persist the identified track for "the song from before" references
            "last_identified_track_id": track_id,
            "last_identified_track_name": song_title,
            "last_identified_track_artist": artist,
        }
    
    # Case 2: Available for purchase
    if in_catalog:
        # Build full message including price info and question
        full_msg = info_msg + f"\n\nThis track is available in our store for **${track_price:.2f}**."
        full_msg += "\n\n**Would you like to purchase it?**"
        
        # HITL: Ask for purchase decision using "choice" type for inline buttons
        # Include ALL the info in the interrupt message so it displays together
        decision = interrupt({
            "type": "choice",
            "title": "Purchase Track?",
            "message": full_msg,
            "options": [
                {"value": "yes", "label": "Yes, buy it!", "style": "primary"},
                {"value": "no", "label": "No thanks", "style": "secondary"}
            ]
        })
        
        if decision.lower() in ["yes", "confirm"]:
            return {
                "messages": [AIMessage(content="Great choice! Let me set up your purchase...")],
                "lyrics_purchase_confirmed": True,
                "pending_track_id": track_id,
                "pending_track_name": song_title,
                "pending_track_price": track_price,
                # ALWAYS persist the identified track for "the song from before" references
                "last_identified_track_id": track_id,
                "last_identified_track_name": song_title,
                "last_identified_track_artist": artist,
            }
        else:
            # User declined - clear pending but KEEP last_identified for future reference
            return {
                "messages": [AIMessage(content="No problem! Let me know if there's anything else I can help you with.")],
                "lyrics_purchase_confirmed": False,
                "pending_track_id": None,
                "pending_track_name": None,
                "pending_track_price": None,
                # ALWAYS persist the identified track for "the song from before" references
                "last_identified_track_id": track_id,
                "last_identified_track_name": song_title,
                "last_identified_track_artist": artist,
            }
    
    # Case 3: Not in catalog - ask about interest
    else:
        # Build full message including info and question
        full_msg = info_msg + "\n\nUnfortunately, this track isn't currently in our catalogue."
        full_msg += "\n\n**Would you like us to consider adding it?**"
        
        # HITL: Ask about adding to catalog
        decision = interrupt({
            "type": "choice",
            "title": "Request This Track?",
            "message": full_msg,
            "options": [
                {"value": "yes", "label": "Yes, add it!", "style": "primary"},
                {"value": "no", "label": "No thanks", "style": "secondary"}
            ]
        })
        
        if decision.lower() in ["yes", "confirm"]:
            return {
                "messages": [AIMessage(content=f"Thanks for your feedback! ðŸŽµ We've noted your interest in **{song_title}** by **{artist}**. We'll consider adding it to our catalogue.\n\nIs there anything else I can help you with?")],
                "lyrics_purchase_confirmed": False,
                "pending_track_id": None,
                "pending_track_name": None,
                "pending_track_price": None,
                # Persist song info even if not in catalog (no track_id, but name/artist available)
                "last_identified_track_id": None,
                "last_identified_track_name": song_title,
                "last_identified_track_artist": artist,
            }
        else:
            return {
                "messages": [AIMessage(content="No problem! Let me know if there's anything else I can help you with.")],
                "lyrics_purchase_confirmed": False,
                "pending_track_id": None,
                "pending_track_name": None,
                "pending_track_price": None,
                # Persist song info even if not in catalog (no track_id, but name/artist available)
                "last_identified_track_id": None,
                "last_identified_track_name": song_title,
                "last_identified_track_artist": artist,
            }


# =============================================================================
# BUILD THE SUBGRAPH
# =============================================================================

def build_lyrics_subgraph() -> StateGraph:
    """Build the lyrics subgraph.
    
    Uses separate Input/Output schemas to prevent message accumulation:
    - Input: Only receives context fields, NOT the full message history
    - Output: Only returns NEW messages generated by this run
    
    Graph structure:
        START â†’ identify_song â†’ check_catalog â†’ get_youtube â†’ present_options (HITL) â†’ END
                     â”‚
                     â–¼
                    END
               (no lyrics/not found)
    
    Uses interrupt() for decisions, consistent with purchase and email_change subgraphs.
    """
    builder = StateGraph(
        LyricsInternalState,
        input=LyricsInputSchema,
        output=LyricsOutputSchema
    )
    
    # Add nodes
    builder.add_node("identify_song", identify_song_node)
    builder.add_node("check_catalog", check_catalog_node)
    builder.add_node("get_youtube", get_youtube_node)
    builder.add_node("present_options", present_options_node)
    
    # Add edges - simple linear flow
    builder.add_edge(START, "identify_song")
    # identify_song uses Command to route to check_catalog or END
    # check_catalog and get_youtube always proceed to next step
    builder.add_edge("present_options", END)
    
    return builder


# Compiled subgraph for import
lyrics_subgraph = build_lyrics_subgraph().compile()
